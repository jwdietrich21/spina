
{            SPINA-Thyr           }
{ Programm zur Berechnung }
{  von  Strukturparametern  }
{        des thyreotropen        }
{            Regelkreises           }
{		  Version 1.0.3		   }

{J. W. Dietrich, Klinikum Innenstadt der LMU MŸnchen 1997-99}

program SPINAThyr;

	uses
		Script;

	const
		RES_BASE = 400;
		APPLE_MENU_ID = 400;
		FILE_MENU_ID = 401;
		EDIT_MENU_ID = 402;

		ABOUT_ITEM = 1;
		ABOUT_ALERT = 400;
		ERROR_ALERT_ID = 401;

		NO_MBAR = RES_BASE;
		NO_MENU = RES_BASE + 1;
		NO_PICTURE = RES_BASE + 2;
		NO_WIND = RES_BASE + 3;
		NO_TEXT = RES_BASE + 4;
		NO_MEMORY = RES_BASE + 5;

		NEW_ITEM = 1;
		CLOSE_ITEM = 2;
		QUIT_ITEM = 7;

		UNDO_ITEM = 1;
		CUT_ITEM = 3;
		COPY_ITEM = 4;
		PASTE_ITEM = 5;
		CLEAR_ITEM = 6;
		COPY_RESULT_ITEM = 8;

		ABOUT_OK_BUTTON = 1;
		CALCULATE_BUTTON = 1;

		EDGE_THRESHOLD = 30;

		WINDOW_HOME_LEFT = 5;
		WINDOW_HOME_TOP = 45;
		NEW_WINDOW_OFFSET = 20;

		ACTIVATING = 1;
		CONTROL_ACTIVATE = 0;
		CONTROL_DEACTIVATE = $FF;

		ON = 1;
		OFF = 0;

		MIN_SLEEP = 60;

		LEAVE_WHERE_IT_IS = FALSE;

		WNE_TRAP_NUM = $60;
		UNIMPL_TRAP_NUM = $9F;

		NIL_STRING = '';
		HOPELESSLY_FATAL_ERROR = 'Der Ressourcenzweig ist beschŠdigt.';

		kENTER = char(3);
		kTAB = char(9);
		kRETURN = char(13);
		kESCAPE = char(27);
		kPERIOD = '.';

		kVisual = 8;

		DEC_POINT = '.';
		DEC_COMMA = ',';
		TEXT_WIDTH = 10;
		TSH_Unit = ' mU/l';
		FT4_Unit = ' ng/dl';
		FT3_Unit = ' pg/ml';

		TSH_Text = 2;
		FT4_Text = 3;
		FT3_Text = 4;

		UFT4 = 1.28e-11;
		UFT3 = 1.54e-12;
		ALPHAT = 0.1;
		BETAT = 1.1e-6;
		THY = 1;
		I = 1;
		DT = 2.75;
		KT = 1;
		KI = 1;
		TBG = 3e-7;
		TBPA = 4.5e-6;
		K30 = 2e9;
		K41 = 2e10;
		K42 = 2e8;
		ALPHA31 = 0.026;
		BETA31 = 8e-6;
		KM1 = 5e-7;

	type
		CaseRecord = record
				TSH, FT4, FT3, GT, GD: real;
				MessageString: Str255;
			end;
		CaseRecordPtr = ^CaseRecord;
		CaseRecordHnd = ^CaseRecordPtr;

	var
		TSH, FT4, FT3, GT, GD: real;
		gDone, gWNEImplemented: Boolean;
		gTheEvent: EventRecord;
		gNewWindowLeft, gNewWindowTop: INTEGER;
		gAboutDialog, gSplashDialog: DialogPtr;
		gCalcButton: ControlHandle;
		gMessageRect: Rect;
		gcalcTitle, gcalcString, gnotcalculatableString, GTs, GDs: Str255;
		gExplanationString, gMessageString, TSH_String, FT4_String, FT3_String: Str255;
		gRefExp, gGTRef, gGDRef, gSignalString, gParameterString: Str255;
		gcalcCounter, gfinalTicks: longint;


{----------------> ErrorHandler <--}

	procedure ErrorHandler (stringNum: INTEGER);
		var
			errorStringH: StringHandle;
			result: INTEGER;
	begin
		errorStringH := GetString(stringNum);
		if errorStringH = nil then
			ParamText(HOPELESSLY_FATAL_ERROR, NIL_STRING, NIL_STRING, NIL_STRING)
		else
			ParamText(errorStringH^^, NIL_STRING, NIL_STRING, NIL_STRING);
		result := StopAlert(ERROR_ALERT_ID, nil);
		ExitToShell;
	end;


{--------------->     IsDAWindow     <--}

	function IsDAWindow (whichWindow: WindowPtr): BOOLEAN;
	begin
		if whichWindow = nil then
			isDaWindow := FALSE
		else
			IsDaWindow := (WindowPeek(whichWindow)^.windowKind < 0);
	end;


{--------------->     IsDialogWindow     <--}

	function IsDialogWindow (theWindow: WindowPtr): Boolean;
	begin
		if theWindow = nil then
			IsDialogWindow := FALSE
		else
			IsDialogWindow := WindowPeek(theWindow)^.windowKind = dialogKind;
	end;


{--------------->     ShowMessage     <--}

	procedure ShowMessage (theWindow: WindowPtr);
		var
			origFont, origSize: INTEGER;
			theString: Str255;
			caseData: CaseRecordHnd;
			oldPort: GrafPtr;
	begin
		if theWindow <> nil then
			begin
				GetPort(oldPort);
				SetPort(theWindow);
				caseData := CaseRecordHnd(GetWRefCon(theWindow));
				if caseData = nil then
					ErrorHandler(NO_MEMORY);
				HLock(Handle(CaseData));
				theString := caseData^^.MessageString;
				HUnlock(Handle(CaseData));
				origFont := theWindow^.txFont;
				origSize := theWindow^.txSize;
				TextFont(applFont);
				TextSize(10);
				TextBox(Pointer(ord(@theString) + 1), length(theString), gMessageRect, teFlushLeft);
				TextFont(origFont);
				TextSize(origSize);
				SetPort(oldPort);
			end;
	end;


{--------------->     DoOutlineControl     <--}

	procedure DoOutlineControl (theControl: univ ControlHandle);
		var
			theOval: INTEGER;
			theRect: Rect;
			origPen: PenState;
			oldPort: GrafPtr;
	begin
		if theControl <> nil then
			begin
				GetPort(oldPort);
				SetPort(theControl^^.contrlOwner);
				GetPenState(origPen);
				PenNormal;

				theRect := theControl^^.contrlRect;
				InsetRect(theRect, -4, -4);
				theOval := ((theRect.bottom - theRect.top) div 2) + 2;
				if (theControl^^.contrlHilite = CONTROL_ACTIVATE) then
					PenPat(black)
				else
					PenPat(gray);
				PenSize(3, 3);
				FrameRoundRect(theRect, theOval, theOval);
				SetPenState(origPen);
				SetPort(oldPort);
			end;
	end;


{--------------->      Calculate     <--}

	procedure Calculate;
	begin
		if TSH > 0 then
			begin
				GT := betaT * (DT + TSH) * (1 + k41 * TBG + k42 * TBPA) * FT4 / (alphaT * TSH);
				GTs := concat(StringOf(1e12 * GT : 5 : 2), ' pmol/s');
			end
		else
			GTs := gnotcalculatableString;
		if FT4 > 0 then
			begin
				GD := beta31 * (kM1 + FT4) * (1 + k30 * TBG) * FT3 / (alpha31 * FT4);
				GDs := concat(StringOf(1e9 * GD : 5 : 2), ' nmol/s');
			end
		else
			GDs := gnotcalculatableString;
	end;


{--------------->      CenterPict     <--}

	procedure CenterPict (thePicture: PicHandle; var myRect: Rect);
		var
			windRect, pictureRect: Rect;
	begin
		WindRect := myRect;
		pictureRect := thePicture^^.picFrame;
		myRect.top := (windRect.bottom - windRect.top - (pictureRect.bottom - pictureRect.top)) div 2 + windRect.top;
		myRect.bottom := myRect.top + (pictureRect.bottom - pictureRect.top);
		myRect.left := (windRect.right - windRect.left - (pictureRect.right - pictureRect.left)) div 2 + windRect.left;
		myRect.right := myRect.left + (pictureRect.right - pictureRect.left);
	end;


{--------------->     DrawPictures     <--}

	procedure DrawPictures (pictureWindow: WindowPtr);
		var
			myRect: Rect;
			thePicture: picHandle;
	begin
		myRect := pictureWindow^.portRect;
		thePicture := GetPicture(RES_BASE + 1);
		if thePicture = nil then
			ErrorHandler(NO_PICTURE);
		SetRect(myRect, 126, 19, 371, 236);
		SetPort(pictureWindow);
		DrawPicture(thePicture, myRect);
		thePicture := GetPicture(RES_BASE + 2);
		if thePicture = nil then
			ErrorHandler(NO_PICTURE);
		SetRect(myRect, 8, 39, 135, 104);
		SetPort(pictureWindow);
		DrawPicture(thePicture, myRect);
	end;


{--------------->     CreateWindow     <--}

	procedure CreateWindow;
		var
			theNewestWindow: DialogPtr;
			oldPort: GrafPtr;
			iType: integer;
			iHandle: Handle;
			iRect: Rect;
			caseData: CaseRecordHnd;
	begin
		theNewestWindow := GetNewDialog(RES_BASE + 1, nil, WindowPtr(-1));
		if theNewestWindow = nil then
			ErrorHandler(NO_WIND);
		if ((screenBits.bounds.right - gNewWindowLeft) < EDGE_THRESHOLD) or ((screenBits.bounds.bottom - gNewWindowTop) < EDGE_THRESHOLD) then
			begin
				gNewWindowLeft := WINDOW_HOME_LEFT;
				gNewWindowTop := WINDOW_HOME_TOP;
			end;
		gcalcTitle := 'Berechnung';
		gcalcCounter := gcalcCounter + 1;
		if gcalcCounter > 1 then
			begin
				NumToString(gcalcCounter, gcalcString);
				gcalcTitle := concat(gcalcTitle, ' ', gcalcString);
			end;
		SetWTitle(theNewestWindow, gcalcTitle);
		gMessageString := gExplanationString;
		caseData := CaseRecordHnd(NewHandle(sizeof(CaseRecord)));
		if caseData = nil then
			ErrorHandler(NO_MEMORY);
		HLock(Handle(CaseData));
		SetWRefCon(theNewestWindow, longint(CaseData));
		caseData^^.TSH := TSH;
		caseData^^.FT4 := FT4;
		caseData^^.FT3 := FT3;
		caseData^^.GT := GT;
		caseData^^.GD := GD;
		caseData^^.MessageString := gMessageString;
		HUnlock(Handle(CaseData));
		MoveWindow(theNewestWindow, gNewWindowLeft, gNewWindowTop, LEAVE_WHERE_IT_IS);
		gNewWindowLeft := gNewWindowLeft + NEW_WINDOW_OFFSET;
		gNewWindowTop := gNewWindowTop + NEW_WINDOW_OFFSET;
		GetDItem(theNewestWindow, TSH_Text, iType, iHandle, iRect);
		SetIText(iHandle, '0');
		SelIText(theNewestWindow, TSH_Text, 0, 32767);
		GetPort(oldPort);
		SetPort(theNewestWindow);
		ShowWindow(theNewestWindow);
		ShowMessage(theNewestWindow);
		GetDItem(theNewestWindow, CALCULATE_BUTTON, iType, iHandle, iRect);
		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);
		DoOutlineControl(iHandle);
		SetPort(oldPort);
	end;


{--------------->      HandleAbout     <--}

	procedure HandleAbout;
		var
			iHit, iType, theTabulator: INTEGER;
			iRect, aboutRect: Rect;
			iHandle: Handle;
			dialogDone: BOOLEAN;

	begin
		if gAboutDialog = nil then
			gAboutDialog := GetNewDialog(RES_BASE, nil, WindowPtr(-1));
		SelectWindow(gAboutDialog);
		ShowWindow(gAboutDialog);
		SetPort(gAboutDialog);
		aboutRect := gAboutDialog^.portRect;

		GetDItem(gAboutDialog, ABOUT_OK_BUTTON, iType, iHandle, iRect);
		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);
		DoOutlineControl(iHandle);

		dialogDone := FALSE;
		while DialogDone = FALSE do
			begin
				ModalDialog(nil, iHit);
				case iHit of
					ABOUT_OK_BUTTON: 
						begin
							HideWindow(gAboutDialog);
							dialogDone := TRUE;
						end;
				end;
			end;
	end;


{--------------->     HandleCopyResult     <--}

	procedure HandleCopyResult (theDialog: DialogPtr);
		var
			caseData: CaseRecordHnd;
			theString: Str255;
			ResultPtr: Ptr;
			thelength: LongInt;
	begin
		caseData := CaseRecordHnd(GetWRefCon(theDialog));
		if caseData = nil then
			ErrorHandler(NO_MEMORY);
		HLock(Handle(CaseData));
		theString := caseData^^.MessageString;
		HUnlock(Handle(CaseData));
		thelength := length(theString);
		ResultPtr := NewPtr(thelength);
		ResultPtr := Ptr(ord(@theString) + 1);
		if ZeroScrap <> noErr then
			ErrorHandler(NO_MEMORY)
		else if PutScrap(thelength, 'TEXT', ResultPtr) <> noErr then
			ErrorHandler(NO_MEMORY);
		DisposPtr(ResultPtr);
	end;


{--------------->     HandleEditChoice     <--}

	procedure HandleEditChoice (theItem: INTEGER);
		var
			result: Boolean;
			theDialog: DialogPtr;
			iErr: OSErr;
	begin
		if IsDialogWindow(frontWindow) then
			begin
				theDialog := frontWindow;
				case theItem of
					CUT_ITEM: 
						begin
							DlgCut(theDialog);
							if ZeroScrap = noErr then
								iErr := TEToScrap;
						end;
					COPY_ITEM: 
						begin
							DlgCopy(theDialog);
							if ZeroScrap = noErr then
								iErr := TEToScrap;
						end;
					PASTE_ITEM: 
						begin
							iErr := TEFromScrap;
							DlgPaste(theDialog);
						end;
					CLEAR_ITEM: 
						DlgDelete(theDialog);
					COPY_RESULT_ITEM: 
						HandleCopyResult(theDialog);
					otherwise
						result := SystemEdit(theItem - 1);
				end;
			end
		else
			result := SystemEdit(theItem - 1);
	end;


{--------------->     NumberForm     <--}

	function NumberForm (compos: integer; theString: Str255): extended;
	{Wandelt String in Flie§kommazahl um}
		var
			num, wholeS, remainderS: Str255;
			whole, remainder: longint;
	begin
		wholeS := copy(theString, 0, compos);
		StringToNum(wholeS, whole);
		remainderS := copy(theString, compos + 1, (length(theString) - compos));
		StringToNum(remainderS, remainder);
		NumberForm := whole + remainder / exp(ln(10) * length(remainderS));
	end;


{--------------->     ValidKey     <--}

	function ValidKey (theKey: char): boolean;
	{BeschrŠnkt Texteingabe auf zulŠssige Zeichen}
		type
			format1 = set of char;
		var
			theformatn, theformatd, theformate, theformato, theformatc, thevalidformat: format1;
	begin
		ValidKey := false;
		theformatn := ['1'..'9', '0', kTAB];
		theformatd := ['.', ','];
		theformate := ['e', 'E'];
		theformato := ['+', '-'];
		theformatc := [char($1c), char($1d), char($1e), char($1f), char($08)];
		thevalidformat := theformatn + theformatd + theformate + theformatc;
		if thekey in thevalidformat then
			ValidKey := true
		else
			SysBeep(30);
	end;

{--------------->     StandardForm     <--}

	function StandardForm (theString: Str255): extended;
		var
			compos: integer;
			num, wholeS, remainderS: Str255;
			whole, remainder: longint;
	begin
		compos := pos(DEC_COMMA, theString);
		if compos > 0 then
			StandardForm := NumberForm(compos, theString)
		else
			begin
				compos := pos(DEC_POINT, theString);
				if compos > 0 then
					StandardForm := NumberForm(compos, theString)
				else
					begin
						StringToNum(theString, whole);
						StandardForm := whole;
					end;
			end;
	end;


{--------------->     HandleFileChoice     <--}

	procedure HandleFileChoice (theItem: INTEGER);
		var
			whichWindow: WindowPtr;
	begin
		case theItem of
			NEW_ITEM: 
				CreateWindow;
			CLOSE_ITEM: 
				begin
					whichWindow := FrontWindow;
					if whichWindow <> nil then
						if IsDialogWindow(WindowPtr(gTheEvent.message)) then
							DisposDialog(whichWindow)
						else
							DisposeWindow(whichWindow);
				end;
			QUIT_ITEM: 
				gDone := TRUE;
		end;
	end;


{--------------->     HandleAppleChoice     <--}

	procedure HandleAppleChoice (theItem: INTEGER);
		var
			accName: Str255;
			accNumber, itemNumber: INTEGER;
			aMenu: MenuHandle;
	begin
		case theItem of
			ABOUT_ITEM: 
				HandleAbout;
			otherwise
				begin
					aMenu := GetMHandle(APPLE_MENU_ID);
					GetItem(aMenu, theItem, accName);
					accNumber := OpenDeskAcc(accName);
				end;
		end;
	end;


{--------------->     HandleMenuChoice     <--}

	procedure HandleMenuChoice (menuChoice: LONGINT);
		var
			theMenu, theItem: INTEGER;
	begin
		if menuChoice <> 0 then
			begin
				theMenu := HiWord(menuChoice);
				theItem := LoWord(menuChoice);

				case theMenu of
					APPLE_MENU_ID: 
						HandleAppleChoice(theItem);
					FILE_MENU_ID: 
						HandleFileChoice(theItem);
					EDIT_MENU_ID: 
						HandleEditChoice(theItem);
				end;

				HiliteMenu(0);
			end;
	end;


{--------------->     AdjustMenus     <--}

	procedure AdjustMenus;
		var
			aMenu: MenuHandle;
	begin
		if FrontWindow = nil then
			begin
				aMenu := GetMHandle(FILE_MENU_ID);
				DisableItem(aMenu, CLOSE_ITEM);
				aMenu := GetMHandle(EDIT_MENU_ID);
				DisableItem(aMenu, UNDO_ITEM);
				DisableItem(aMenu, CUT_ITEM);
				DisableItem(aMenu, COPY_ITEM);
				DisableItem(aMenu, PASTE_ITEM);
				DisableItem(aMenu, CLEAR_ITEM);
				DisableItem(aMenu, COPY_RESULT_ITEM);
			end
		else
			begin
				aMenu := GetMHandle(FILE_MENU_ID);
				EnableItem(aMenu, CLOSE_ITEM);
			end;

		aMenu := GetMHandle(EDIT_MENU_ID);
		if IsDaWindow(FrontWindow) then
			begin
				EnableItem(aMenu, UNDO_ITEM);
				EnableItem(aMenu, CUT_ITEM);
				EnableItem(aMenu, COPY_ITEM);
				EnableItem(aMenu, PASTE_ITEM);
				EnableItem(aMenu, CLEAR_ITEM);
				DisableItem(aMenu, COPY_RESULT_ITEM);
			end
		else
			begin
				DisableItem(aMenu, UNDO_ITEM);
				EnableItem(aMenu, CUT_ITEM);
				EnableItem(aMenu, COPY_ITEM);
				EnableItem(aMenu, PASTE_ITEM);
				EnableItem(aMenu, CLEAR_ITEM);
				EnableItem(aMenu, COPY_RESULT_ITEM);
			end;
	end;


{--------------->     HandleInput     <--}

	procedure HandleInput (whichWindow: WindowPtr);
		var
			subsString: Str255;
			sizeL: LongInt;
			iType, item, result: Integer;
			iHandle, point_handle, comma_handle, text_handle: Handle;
			iRect: Rect;
			myErr: OSErr;
			caseData: CaseRecordHnd;
	begin
		subsString := DEC_POINT;
		GetDItem(whichWindow, TSH_Text, iType, iHandle, iRect);
		GetIText(iHandle, TSH_String);
		TSH := StandardForm(TSH_String);
		GetDItem(whichWindow, FT4_Text, iType, iHandle, iRect);
		GetIText(iHandle, FT4_String);
		FT4 := StandardForm(FT4_String);
		FT4 := FT4 * UFT4;
		GetDItem(whichWindow, FT3_Text, iType, iHandle, iRect);
		GetIText(iHandle, FT3_String);
		FT3 := StandardForm(FT3_String);
		FT3 := FT3 * UFT3;
		Calculate;
		gMessageString := concat(gSignalString, kReturn, '   TSH: ', TSH_String, TSH_Unit, kReturn, '   FT4: ', FT4_String, FT4_Unit, kReturn, '   FT3: ', FT3_String, FT3_Unit);
		gMessageString := concat(gMessageString, kReturn, gParameterString, kReturn, '   GT: ', GTs, kReturn, '   GD: ', GDs);
		gMessageString := concat(gMessageString, kReturn, gRefExp, kReturn, gGTRef, kReturn, gGDRef);
		caseData := CaseRecordHnd(NewHandle(sizeof(CaseRecord)));
		if caseData = nil then
			ErrorHandler(NO_MEMORY);
		HLock(Handle(CaseData));
		SetWRefCon(whichWindow, longint(CaseData));
		caseData^^.TSH := TSH;
		caseData^^.FT4 := FT4;
		caseData^^.FT3 := FT3;
		caseData^^.GT := GT;
		caseData^^.GD := GD;
		caseData^^.MessageString := gMessageString;
		HUnlock(Handle(CaseData));
		ShowMessage(whichWindow);
	end;


{----------------> DoContentClick <--}

	procedure DoContentClick (whichWindow: WindowPtr);
		var
			item: Integer;
			theDialog: DialogPtr;
	begin
		if IsDialogEvent(gTheEvent) then
			if DialogSelect(gTheEvent, theDialog, item) then
				if item = CALCULATE_BUTTON then
					HandleInput(whichWindow);
	end;


{----------------> HandleMouseDown <--}

	procedure HandleMouseDown;
		var
			whichWindow: WindowPtr;
			thePart: INTEGER;
			menuChoice, windSize: LONGINT;
	begin
		thePart := FindWindow(gTheEvent.where, whichWindow);
		case thePart of
			inMenuBar: 
				begin
					menuChoice := MenuSelect(gTheEvent.where);
					HandleMenuChoice(menuChoice);
				end;
			inSysWindow: 
				SystemClick(gTheEvent, whichWindow);
			inDrag: 
				DragWindow(whichWindow, gTheEvent.where, GetGrayRgn^^.rgnBBox);
			inGoAway: 
				if TrackGoAway(whichWindow, gTheEvent.where) then
					if IsDialogWindow(WindowPtr(gTheEvent.message)) then
						DisposDialog(whichWindow)
					else
						DisposeWindow(whichWindow);
			inContent: 
				if whichWindow <> FrontWindow then
					SelectWindow(whichWindow)
				else
					DoContentClick(whichWindow);
		end;
	end;


{----------------> HandleKeyDown <--}

	procedure HandleKeyDown;
		var
			key: Char;
			iType, item: Integer;
			iHandle: Handle;
			iRect: Rect;
			finalTicks: LongInt;
			handled: Boolean;
			theDialog: DialogPtr;
	begin
		handled := FALSE;
		theDialog := FrontWindow;
		key := Char(BAnd(gTheEvent.message, charCodeMask));
		if (key = char(kRETURN)) or (key = char(kENTER)) then
			begin
				if theDialog <> nil then
					begin
						SetPort(theDialog);
						GetDItem(theDialog, CALCULATE_BUTTON, iType, iHandle, iRect);
						HiliteControl(ControlHandle(iHandle), inButton);
						Delay(kVISUAL, finalTicks);
						HiliteControl(ControlHandle(iHandle), 0);
						HandleInput(theDialog);
						handled := TRUE;
					end
				else
					begin
						item := NoteAlert(RES_BASE + 10, nil);
						handled := true;
					end;
			end;
		if (BitAnd(gTheEvent.modifiers, cmdKey) <> 0) then
			begin
				AdjustMenus;
				HandleMenuChoice(MenuKey(key));
				handled := TRUE;
			end;
		if not handled then
			if theDialog <> nil then
				begin
					if validkey(key) then
						handled := DialogSelect(gTheEvent, theDialog, item);
				end
			else
				item := NoteAlert(RES_BASE + 10, nil);
	end;



{----------------> HandleEvent <--}

	procedure HandleEvent;
		var
			theChar: CHAR;
			gotEvent, result: BOOLEAN;
			oldPort: GrafPtr;
			window: WindowPtr;
			iHit, state: Integer;
			control: ControlHandle;
			iType, item: integer;
			iHandle: Handle;
			iRect: Rect;
	begin
		if gWNEImplemented then
			gotEvent := WaitNextEvent(everyEvent, gTheEvent, MIN_SLEEP, nil)
		else
			begin
				SystemTask;
				gotEvent := GetNextEvent(everyEvent, gTheEvent);
			end;
		if gotEvent then
			case gTheEvent.what of
				mouseDown: 
					begin
						AdjustMenus;
						HandleMouseDown;
					end;
				keyDown, autoKey: 
					begin
						HandleKeyDown;
					end;
				activateEvt: 
					begin
						state := BAnd(gTheEvent.modifiers, activeFlag);
						if (IsDialogWindow(WindowPtr(gTheEvent.message))) and (WindowPtr(gTheEvent.message) <> gAboutDialog) then
							begin
								control := WindowPeek(WindowPtr(gTheEvent.message))^.controlList;
								while control <> nil do
									begin
										HiliteControl(control, state + 255 mod 256);
										control := control^^.nextControl;
										GetDItem(WindowPtr(gTheEvent.message), CALCULATE_BUTTON, iType, iHandle, iRect);
										DoOutlineControl(iHandle);
{result := DialogSelect(gTheEvent, WindowPtr(gTheEvent.message), item);}
									end;
							end;
					end;
				updateEvt: 
					if not IsDAWindow(WindowPtr(gTheEvent.message)) then
						begin
							AdjustMenus;
							GetPort(oldPort);
							SetPort(WindowPtr(gTheEvent.message));
							BeginUpdate(WindowPtr(gTheEvent.message));
							UpdateDialog(WindowPtr(gTheEvent.message), WindowPtr(gTheEvent.message)^.visRgn);
							ShowMessage(WindowPtr(gTheEvent.message));
							EndUpdate(WindowPtr(gTheEvent.message));
							GetDItem(WindowPtr(gTheEvent.message), CALCULATE_BUTTON, iType, iHandle, iRect);
							DoOutlineControl(iHandle);
							SetPort(oldPort);
						end;
				nullEvent: 
					begin
						window := FrontWindow;
						if IsDialogWindow(FrontWindow) then
							result := DialogSelect(gTheEvent, window, item);
					end;
			end
		else
			begin
				window := FrontWindow;
				if IsDialogWindow(FrontWindow) then
					result := DialogSelect(gTheEvent, window, item);
			end;
	end;


{----------------> MainLoop <--}

	procedure MainLoop;
	begin
		gDone := FALSE;

		gWNEImplemented := (NGetTrapAddress(WNE_TRAP_NUM, ToolTrap) <> NGetTrapAddress(UNIMPL_TRAP_NUM, ToolTrap));
		while (gDone = FALSE) do
			HandleEvent;
	end;


{----------------> MenuBarInit <--}

	procedure MenuBarInit;
		var
			myMenuBar: Handle;
			aMenu: MenuHandle;
	begin
		myMenuBar := GetNewMBar(RES_BASE);
		if myMenuBar = nil then
			ErrorHandler(NO_MBAR);
		SetMenuBar(myMenuBar);
{--- DisposHandle(myMenuBar); ---}

		aMenu := GetMHandle(APPLE_MENU_ID);
		if aMenu = nil then
			ErrorHandler(NO_MENU);

		AddResMenu(aMenu, 'DRVR');

		aMenu := GetMenu(EDIT_MENU_ID);
		if aMenu = nil then
			ErrorHandler(NO_MENU);

		aMenu := GetMenu(FILE_MENU_ID);
		if aMenu = nil then
			ErrorHandler(NO_MENU);

		DrawMenuBar;
	end;


{----------------> SPINA-Thyr <--}
begin
	MenuBarInit;
	gSplashDialog := GetNewDialog(RES_BASE + 3, nil, WindowPtr(-1));
	SelectWindow(gSplashDialog);
	ShowWindow(gSplashDialog);
	SetPort(gSplashDialog);
	DrawDialog(gSplashDialog);
	gNewWindowLeft := WINDOW_HOME_LEFT;
	gNewWindowTop := WINDOW_HOME_TOP;
	gcalcCounter := 0;
	SetRect(gMessageRect, 8, 110, 150, 240);
	GetIndString(gnotcalculatableString, RES_BASE, 1);
	GetIndString(gExplanationString, RES_BASE, 2);
	GetIndString(gRefExp, RES_BASE, 3);
	GetIndString(gGTRef, RES_BASE, 4);
	GetIndString(gGDRef, RES_BASE, 5);
	GetIndString(gSignalString, RES_BASE, 6);
	GetIndString(gParameterString, RES_BASE, 7);
	Delay(30, gfinalTicks);
	HideWindow(gSplashDialog);
	CreateWindow;
	MainLoop;
end.