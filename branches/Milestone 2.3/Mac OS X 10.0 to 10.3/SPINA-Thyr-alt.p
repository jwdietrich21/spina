{            SPINA-Thyr           }{ Programm zur Berechnung }{  von  Strukturparametern  }{        des thyreotropen        }{            Regelkreises           }{		  Version 2.3		   }{J. W. Dietrich, Klinikum Innenstadt der LMU MŸnchen 1997-2001}{$setc TARGET_API_MAC_CARBON := true}{$setc CALL_NOT_IN_CARBON := false}{$setc TYPED_FUNCTION_POINTERS := false}{$setc GENERATINGCFM := true}{$setc PM_USE_SESSION_APIS := false}{$setc OPAQUE_UPP_TYPES := false}program SPINAThyr;	uses	Controls, Dialogs, Fonts, Lists, TextEdit, Menus, Packages, Processes, 	Memory, Strings, Resources, QuickDraw, SegLoad, Scrap, Sound, Devices,	ToolUtils, OSUtils, Windows, Events, Script, Printing;	const		RES_BASE = 400;		APPLE_MENU_ID = 400;		FILE_MENU_ID = 401;		EDIT_MENU_ID = 402;		TSH_POPUP_MENU_ID = 410;		FT4_POPUP_MENU_ID = 411;		FT3_POPUP_MENU_ID = 412;		NOT_A_NORMAL_MENU = -1;		ABOUT_ITEM = 1;		ABOUT_ALERT = 400;		ERROR_ALERT_ID = 401;		NO_MBAR = RES_BASE;		NO_MENU = RES_BASE + 1;		NO_PICTURE = RES_BASE + 2;		NO_WIND = RES_BASE + 3;		NO_TEXT = RES_BASE + 4;		NO_MEMORY = RES_BASE + 5;		NEW_ITEM = 1;		CLOSE_ITEM = 2;		PAGE_SETUP_ITEM = 4;		PRINT_ITEM = 5;		QUIT_ITEM = 7;		UNDO_ITEM = 1;		CUT_ITEM = 3;		COPY_ITEM = 4;		PASTE_ITEM = 5;		CLEAR_ITEM = 6;		COPY_RESULT_ITEM = 8;		POPUP_LEFT = 120;		POPUP_TOP = 190;		POPUP_RIGHT = 180;		POPUP_BOTTOM = 207;		SHADOW_PIXELS = 1;		RIGHT_MARGIN = 20;		BOTTOM_MARGIN = 4;		LEFT_MARGIN = 5;		PIXEL_FOR_TOP_LINE = 1;		POPUP_SIZE = 9;		ABOUT_OK_BUTTON = 1;		CALCULATE_BUTTON = 1;		EDGE_THRESHOLD = 30;		WINDOW_HOME_LEFT = 5;		WINDOW_HOME_TOP = 45;		NEW_WINDOW_OFFSET = 20;		ACTIVATING = 1;		CONTROL_ACTIVATE = 0;		CONTROL_DEACTIVATE = $FF;		ON = 1;		OFF = 0;		MIN_SLEEP = 60;		LEAVE_WHERE_IT_IS = FALSE;		WNE_TRAP_NUM = $60;		UNIMPL_TRAP_NUM = $9F;		PAGE_MARGIN = 30;		NIL_STRING = '';		HOPELESSLY_FATAL_ERROR = 'Der Ressourcenzweig ist beschŠdigt.';		kENTER = char(3);		kTAB = char(9);		kRETURN = char(13);		kESCAPE = char(27);		kPERIOD = '.';		kVisual = 8;		inButton=10;		inCheckBox=11;		inUpButton=20;		inDownButton=21;		inThumb=129;		DEC_POINT = '.';		DEC_COMMA = ',';		TEXT_WIDTH = 10;		TSH_Unit = ' mU/l';		FT4_Unit = ' ng/dl';		FT3_Unit = ' pg/ml';		TSH_Text = 2;		FT4_Text = 3;		FT3_Text = 4;		TSH_Unit_Item = 7;		FT4_Unit_Item = 9;		FT3_Unit_Item = 8;		UFT4 = 1.28e-11;		UFT3 = 1.54e-12;		ALPHAT = 0.1;		BETAT = 1.1e-6;		THY = 1;		I = 1;		DT = 2.75;		KT = 1;		KI = 1;		TBG = 3e-7;		TBPA = 4.5e-6;		K30 = 2e9;		K41 = 2e10;		K42 = 2e8;		ALPHA31 = 0.026;		BETA31 = 8e-6;		KM1 = 5e-7;	type		CaseRecord = record			TSH, FT4, FT3, GT, GD: real;			TSHUnitFactor, FT4UnitFactor, FT3UnitFactor: real;			TSHPopUpItem, FT4PopUpItem, FT3PopUpItem: integer;			TSHPopUpMenu, FT4PopUpMenu, FT3PopUpMenu: MenuHandle;			MessageString: Str255;		end;		CaseRecordPtr = ^CaseRecord;		CaseRecordHnd = ^CaseRecordPtr;	var		TSH, FT4, FT3, GT, GD: real;		gDone, gWNEImplemented: Boolean;		gTheEvent: EventRecord;		gNewWindowLeft, gNewWindowTop: integer;		gTSHPopUpRect, gFT4PopUpRect, gFT3PopUpRect: Rect;		gAboutDialog, gSplashDialog: DialogPtr;		gCalcButton: ControlHandle;		gMessageRect: Rect;		gcalcTitle, gcalcString, gnotcalculatableString, GTs, GDs: Str255;		gExplanationString, gMessageString, TSH_String, FT4_String, FT3_String: Str255;		gRefExp, gGTRef, gGDRef, gSignalString, gParameterString: Str255;		gPatName, gPatBirthday, gPatSender, gChooserName, gPrintingDate, gExaminationDate: Str255;		gcalcCounter: longint;		gPrintRecordH: THPrint;		gfinalTicks:UInt32;{----------------> ErrorHandler <--}	procedure ErrorHandler (stringNum: INTEGER);		var			errorStringH: StringHandle;			result: INTEGER;	begin		errorStringH := GetString(stringNum);		if errorStringH = nil then			ParamText(HOPELESSLY_FATAL_ERROR, NIL_STRING, NIL_STRING, NIL_STRING)		else			ParamText(errorStringH^^, NIL_STRING, NIL_STRING, NIL_STRING);		result := StopAlert(ERROR_ALERT_ID, nil);		ExitToShell;	end;{--------------->     IsDAWindow     <--}	function IsDAWindow (whichWindow: WindowPtr): BOOLEAN;	begin		if whichWindow = nil then			isDaWindow := FALSE		else			IsDaWindow := (WindowPeek(whichWindow)^.windowKind < 0);	end;{--------------->     IsDialogWindow     <--}	function IsDialogWindow (theWindow: WindowPtr): Boolean;	begin		if theWindow = nil then			IsDialogWindow := FALSE		else			IsDialogWindow := WindowPeek(theWindow)^.windowKind = dialogKind;	end;{----------------> PrintInit <--}	procedure PrintInit;	begin		PrOpen;		gPrintRecordH := THPrint(NewHandle(sizeof(TPrint)));		PrintDefault(gPrintRecordH);		prClose;	end;{----------------> PageSetup <--}	procedure PageSetup;		var			keepGoing: boolean;	begin		prOpen;		keepGoing := PrStlDialog(gPrintRecordH);		prClose;	end;{----------------> Print <--}	procedure Print;		var			keepGoing: boolean;			thePict: PicHandle;			theWindow: WindowPtr;			printPort: TPPrPort;			printStatus: TPPrStatusRef;			origFont, origSize: INTEGER;			oldPort: GrafPtr;			DrawingRect, tempRect: Rect;			caseData: CaseRecordHnd;			theString, chooserString, dateString: Str255;			currentTime: UInt32;	begin		theWindow := frontWindow;		if IsDialogWindow(theWindow) then			begin				prOpen;				keepGoing := PrJobDialog(gPrintRecordH);				if keepGoing then					begin						with DrawingRect do							begin								left := gPrintRecordH^^.prInfo.rPage.left + 2 * PAGE_MARGIN;								top := gPrintRecordH^^.prInfo.rPage.top + PAGE_MARGIN;								right := gPrintRecordH^^.prInfo.rPage.right - PAGE_MARGIN;								bottom := gPrintRecordH^^.prInfo.rPage.bottom - PAGE_MARGIN;							end;						tempRect := DrawingRect;						thePict := GetPicture(RES_BASE + 2);						if thePict = nil then							ErrorHandler(NO_PICTURE);						with thePict^^.picFrame do							begin								tempRect.right := tempRect.left + (right - left) div 2;								tempRect.bottom := tempRect.top + (bottom - top) div 2;							end;						GetPort(oldPort);						HLock(Handle(thePict));						printPort := TPPrPort(PrOpenDoc(gPrintRecordH, nil, nil));						if(OSErr(PrError) = noErr) then						PrOpenPage(pointer(printPort), nil);						if(OSErr(PrError) = noErr) then						begin							DrawPicture(thePict, tempRect);							MoveTo(tempRect.left, tempRect.bottom + 5);							LineTo(DrawingRect.right, tempRect.bottom + 5);							origFont := theWindow^.txFont;							origSize := theWindow^.txSize;							TextFont(applFont);							TextSize(10);							with tempRect do								begin									top := bottom + 30;									right := DrawingRect.right;									bottom := top + 3 * 10 * 2;								end;							theString := concat(gPatName, kReturn, gPatBirthday, kReturn, gPatSender, kReturn, gExaminationDate);							TETextBox(Pointer(ord(@theString) + 1), length(theString), tempRect, teFlushLeft);							with tempRect do								begin									top := bottom + 10;									right := DrawingRect.right;									bottom := top + gMessageRect.bottom - gMessageRect.top;								end;							caseData := CaseRecordHnd(GetWRefCon(theWindow));							if caseData = nil then								ErrorHandler(NO_MEMORY);							HLock(Handle(CaseData));							theString := caseData^^.MessageString;							HUnlock(Handle(CaseData));							TETextBox(Pointer(ord(@theString) + 1), length(theString), tempRect, teFlushLeft);							MoveTo(DrawingRect.left, DrawingRect.bottom - 20);							chooserString := Str255(GetString(-16096)^^);							GetDateTime(currentTime);							IUDateString(currentTime, 1, dateString);							theString := concat(gChooserName, chooserString, ' ¥ ', gPrintingDate, dateString);							DrawString(theString);							TextFont(origFont);							TextSize(origSize);							PrClosePage(pointer(printPort));						end;						PrCloseDoc(pointer(printPort));						if ((gPrintRecordH^^.prJob.bJDocLoop = bSpoolLoop) and (PrError = noErr)) then							PrPicFile(gPrintRecordH, nil, nil, nil, printStatus);						HUnlock(Handle(thePict));						SetPort(oldPort);						prClose;					end;			end;	end;{----------------> DrawPopUpItems <--}	procedure DrawPopUpItems (theWindow: WindowPtr);		var			menuItem: Str255;			ItemLeftMargin, arrowHeight, arrowWidth: integer;			caseData: CaseRecordHnd;			theArrow: PicHandle;			arrowRect: Rect;	begin		theArrow := GetPicture(RES_BASE + 10);		arrowHeight := theArrow^^.picFrame.bottom - theArrow^^.picFrame.top;		arrowWidth := theArrow^^.picFrame.right - theArrow^^.picFrame.left;		caseData := CaseRecordHnd(GetWRefCon(theWindow));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		GetMenuItemText(caseData^^.TSHPopUpMenu, caseData^^.TSHPopUpItem, menuItem);		ItemLeftMargin := (gTSHPopUpRect.right - gTSHPopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gTSHPopUpRect;		with arrowRect do			begin				top := gTSHPopUpRect.top + 6;				right := gTSHPopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gTSHPopUpRect.left + itemLeftMargin, gTSHPopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		GetMenuItemText(caseData^^.FT4PopUpMenu, caseData^^.FT4PopUpItem, menuItem);		ItemLeftMargin := (gFT4PopUpRect.right - gFT4PopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gFT4PopUpRect;		with arrowRect do			begin				top := gFT4PopUpRect.top + 6;				right := gFT4PopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gFT4PopUpRect.left + itemLeftMargin, gFT4PopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		GetMenuItemText(caseData^^.FT3PopUpMenu, caseData^^.FT3PopUpItem, menuItem);		ItemLeftMargin := (gFT3PopUpRect.right - gFT3PopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gFT3PopUpRect;		with arrowRect do			begin				top := gFT3PopUpRect.top + 6;				right := gFT3PopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gFT3PopUpRect.left + itemLeftMargin, gFT3PopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		HUnlock(Handle(CaseData));	end;{----------------> DrawPopUps <--}	procedure DrawPopUps (theWindow: WindowPtr);		var			origSize, origFont: integer;			iType: integer;			iHandle: Handle;			iRect: Rect;	begin		origSize := theWindow^.txSize;		origFont := theWindow^.txFont;		TextSize(POPUP_SIZE);		TextFont(applFont);		GetDialogItem(theWindow, TSH_Unit_Item, iType, iHandle, iRect);		gTSHPopUpRect := iRect;		FrameRect(gTSHPopUpRect);		with gTSHPopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		GetDialogItem(theWindow, FT4_Unit_Item, iType, iHandle, iRect);		gFT4PopUpRect := iRect;		FrameRect(gFT4PopUpRect);		with gFT4PopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		GetDialogItem(theWindow, FT3_Unit_Item, iType, iHandle, iRect);		gFT3PopUpRect := iRect;		FrameRect(gFT3PopUpRect);		with gFT3PopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		DrawPopUpItems(theWindow);		TextSize(origSize);		TextFont(origFont);	end;{----------------> PopUpMenuInit <--}	procedure PopUpMenuInit (whichWindow: WindowPtr);		var			caseData: CaseRecordHnd;	begin		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		caseData^^.TSHPopUpMenu := GetMenu(TSH_POPUP_MENU_ID);		InsertMenu(caseData^^.TSHPopUpMenu, NOT_A_NORMAL_MENU);		caseData^^.TSHPopUpItem := 1;		caseData^^.TSHUnitFactor := 1;		caseData^^.FT4PopUpMenu := GetMenu(FT4_POPUP_MENU_ID);		InsertMenu(caseData^^.FT4PopUpMenu, NOT_A_NORMAL_MENU);		caseData^^.FT4PopUpItem := 1;		caseData^^.FT4UnitFactor := 1;		caseData^^.FT3PopUpMenu := GetMenu(FT3_POPUP_MENU_ID);		InsertMenu(caseData^^.FT3PopUpMenu, NOT_A_NORMAL_MENU);		caseData^^.FT3PopUpItem := 1;		caseData^^.FT3UnitFactor := 1;		HUnlock(Handle(CaseData));	end;{--------------->     ShowMessage     <--}	procedure ShowMessage (theWindow: WindowPtr);		var			origFont, origSize: INTEGER;			theString: Str255;			caseData: CaseRecordHnd;			oldPort: GrafPtr;	begin		if theWindow <> nil then			begin				GetPort(oldPort);				SetPort(theWindow);				caseData := CaseRecordHnd(GetWRefCon(theWindow));				if caseData = nil then					ErrorHandler(NO_MEMORY);				HLock(Handle(CaseData));				theString := caseData^^.MessageString;				HUnlock(Handle(CaseData));				origFont := theWindow^.txFont;				origSize := theWindow^.txSize;				TextFont(applFont);				TextSize(10);				TETextBox(Pointer(ord(@theString) + 1), length(theString), gMessageRect, teFlushLeft);				TextFont(origFont);				TextSize(origSize);				SetPort(oldPort);			end;	end;{--------------->     DoOutlineControl     <--}	procedure DoOutlineControl (theControl: univ ControlHandle);		var			theOval: INTEGER;			theRect: Rect;			origPen: PenState;			oldPort: GrafPtr;	begin		if theControl <> nil then			begin				GetPort(oldPort);				SetPort(theControl^^.contrlOwner);				GetPenState(origPen);				PenNormal;				theRect := theControl^^.contrlRect;				InsetRect(theRect, -4, -4);				theOval := ((theRect.bottom - theRect.top) div 2) + 2;				if (theControl^^.contrlHilite = CONTROL_ACTIVATE) then					PenPat(qd.black)				else					PenPat(qd.gray);				PenSize(3, 3);				FrameRoundRect(theRect, theOval, theOval);				SetPenState(origPen);				SetPort(oldPort);			end;	end;{--------------->      Calculate     <--}	procedure Calculate;	begin		if TSH > 0 then			begin				GT := betaT * (DT + TSH) * (1 + k41 * TBG + k42 * TBPA) * FT4 / (alphaT * TSH);				GTs := concat(StringOf(1e12 * GT : 5 : 2), ' pmol/s');			end		else			GTs := gnotcalculatableString;		if FT4 > 0 then			begin				GD := beta31 * (kM1 + FT4) * (1 + k30 * TBG) * FT3 / (alpha31 * FT4);				GDs := concat(StringOf(1e9 * GD : 5 : 2), ' nmol/s');			end		else			GDs := gnotcalculatableString;	end;{--------------->      CenterPict     <--}	procedure CenterPict (thePicture: PicHandle; var myRect: Rect);		var			windRect, pictureRect: Rect;	begin		WindRect := myRect;		pictureRect := thePicture^^.picFrame;		myRect.top := (windRect.bottom - windRect.top - (pictureRect.bottom - pictureRect.top)) div 2 + windRect.top;		myRect.bottom := myRect.top + (pictureRect.bottom - pictureRect.top);		myRect.left := (windRect.right - windRect.left - (pictureRect.right - pictureRect.left)) div 2 + windRect.left;		myRect.right := myRect.left + (pictureRect.right - pictureRect.left);	end;{--------------->     DrawPictures     <--}	procedure DrawPictures (pictureWindow: WindowPtr);		var			myRect: Rect;			thePicture: picHandle;	begin		myRect := pictureWindow^.portRect;		thePicture := GetPicture(RES_BASE + 1);		if thePicture = nil then			ErrorHandler(NO_PICTURE);		SetRect(myRect, 126, 19, 371, 236);		SetPort(pictureWindow);		DrawPicture(thePicture, myRect);		thePicture := GetPicture(RES_BASE + 2);		if thePicture = nil then			ErrorHandler(NO_PICTURE);		SetRect(myRect, 8, 39, 135, 104);		SetPort(pictureWindow);		DrawPicture(thePicture, myRect);	end;{--------------->     CreateWindow     <--}	procedure CreateWindow;		var			theNewestWindow: DialogPtr;			oldPort: GrafPtr;			iType: integer;			iHandle: Handle;			iRect: Rect;			caseData: CaseRecordHnd;	begin		theNewestWindow := GetNewDialog(RES_BASE + 1, nil, WindowPtr(-1));		if theNewestWindow = nil then			ErrorHandler(NO_WIND);		if ((qd.screenBits.bounds.right - gNewWindowLeft) < EDGE_THRESHOLD) or ((qd.screenBits.bounds.bottom - gNewWindowTop) < EDGE_THRESHOLD) then			begin				gNewWindowLeft := WINDOW_HOME_LEFT;				gNewWindowTop := WINDOW_HOME_TOP;			end;		gcalcTitle := 'Berechnung';		gcalcCounter := gcalcCounter + 1;		if gcalcCounter > 1 then			begin				NumToString(gcalcCounter, gcalcString);				gcalcTitle := concat(gcalcTitle, ' ', gcalcString);			end;		SetWTitle(theNewestWindow, gcalcTitle);		gMessageString := gExplanationString;		caseData := CaseRecordHnd(NewHandle(sizeof(CaseRecord)));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		SetWRefCon(theNewestWindow, longint(CaseData));		caseData^^.TSH := TSH;		caseData^^.FT4 := FT4;		caseData^^.FT3 := FT3;		caseData^^.GT := GT;		caseData^^.GD := GD;		caseData^^.MessageString := gMessageString;		HUnlock(Handle(CaseData));		MoveWindow(theNewestWindow, gNewWindowLeft, gNewWindowTop, LEAVE_WHERE_IT_IS);		gNewWindowLeft := gNewWindowLeft + NEW_WINDOW_OFFSET;		gNewWindowTop := gNewWindowTop + NEW_WINDOW_OFFSET;		GetDialogItem(theNewestWindow, TSH_Text, iType, iHandle, iRect);		SetDialogItemText(iHandle, '0');		SelectDialogItemText(theNewestWindow, TSH_Text, 0, 32767);		GetPort(oldPort);		SetPort(theNewestWindow);		ShowWindow(theNewestWindow);		ShowMessage(theNewestWindow);		GetDialogItem(theNewestWindow, CALCULATE_BUTTON, iType, iHandle, iRect);		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);		DoOutlineControl(iHandle);		PopUpMenuInit(theNewestWindow);		SetPort(oldPort);	end;{--------------->      HandleAbout     <--}	procedure HandleAbout;		var			iHit, iType, theTabulator: INTEGER;			iRect, aboutRect: Rect;			iHandle: Handle;			dialogDone: BOOLEAN;	begin		if gAboutDialog = nil then			gAboutDialog := GetNewDialog(RES_BASE, nil, WindowPtr(-1));		SelectWindow(gAboutDialog);		ShowWindow(gAboutDialog);		SetPort(gAboutDialog);		aboutRect := gAboutDialog^.portRect;		GetDialogItem(gAboutDialog, ABOUT_OK_BUTTON, iType, iHandle, iRect);		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);		DoOutlineControl(iHandle);		dialogDone := FALSE;		while DialogDone = FALSE do			begin				ModalDialog(nil, iHit);				case iHit of					ABOUT_OK_BUTTON: 						begin							HideWindow(gAboutDialog);							dialogDone := TRUE;						end;				end;			end;	end;{--------------->     HandleCopyResult     <--}	procedure HandleCopyResult (theDialog: DialogPtr);		var			caseData: CaseRecordHnd;			theString: Str255;			ResultPtr: Ptr;			thelength: LongInt;	begin		caseData := CaseRecordHnd(GetWRefCon(theDialog));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		theString := caseData^^.MessageString;		HUnlock(Handle(CaseData));		thelength := length(theString);		ResultPtr := NewPtr(thelength);		ResultPtr := Ptr(ord(@theString) + 1);		if ClearCurrentScrap <> noErr then			ErrorHandler(NO_MEMORY)		else if PutScrap(thelength, 'TEXT', ResultPtr) <> noErr then			ErrorHandler(NO_MEMORY);		DisposePtr(ResultPtr);	end;{--------------->     HandleEditChoice     <--}	procedure HandleEditChoice (theItem: INTEGER);		var			result: Boolean;			theDialog: DialogPtr;			iErr: OSErr;	begin		if IsDialogWindow(frontWindow) then			begin				theDialog := frontWindow;				case theItem of					CUT_ITEM: 						begin							DialogCut(theDialog);							if ZeroScrap = noErr then								iErr := TEToScrap;						end;					COPY_ITEM: 						begin							DialogCopy(theDialog);							if ZeroScrap = noErr then								iErr := TEToScrap;						end;					PASTE_ITEM: 						begin							iErr := TEFromScrap;							DialogPaste(theDialog);						end;					CLEAR_ITEM: 						DialogDelete(theDialog);					COPY_RESULT_ITEM: 						HandleCopyResult(theDialog);					{otherwise						result := SystemEdit(theItem - 1);}				end;			end		else		;			{result := SystemEdit(theItem - 1)};	end;{--------------->     NumberForm     <--}	function NumberForm (compos: integer; theString: Str255): extended;	{Wandelt String in Flie§kommazahl um}		var			num, wholeS, remainderS: Str255;			whole, remainder: longint;	begin		wholeS := copy(theString, 1, compos-1);		StringToNum(wholeS, whole);		remainderS := copy(theString, compos + 1, (length(theString) - compos));		StringToNum(remainderS, remainder);		NumberForm := whole + remainder / exp(ln(10) * length(remainderS));	end;{--------------->     ValidKey     <--}	function ValidKey (theKey: char): boolean;	{BeschrŠnkt Texteingabe auf zulŠssige Zeichen}		type			format1 = set of char;		var			theformatn, theformatd, theformate, theformato, theformatc, thevalidformat: format1;	begin		ValidKey := false;		theformatn := ['1'..'9', '0', kTAB];		theformatd := ['.', ','];		theformate := ['e', 'E'];		theformato := ['+', '-'];		theformatc := [char($1c), char($1d), char($1e), char($1f), char($08)];		thevalidformat := theformatn + theformatd + theformate + theformatc;		if thekey in thevalidformat then			ValidKey := true		else			SysBeep(30);	end;{--------------->     StandardForm     <--}	function StandardForm (theString: Str255): extended;		var			compos: integer;			num, wholeS, remainderS: Str255;			whole, remainder: longint;	begin		compos := pos(DEC_COMMA, theString);		if compos > 0 then			StandardForm := NumberForm(compos, theString)		else			begin				compos := pos(DEC_POINT, theString);				if compos > 0 then					StandardForm := NumberForm(compos, theString)				else					begin						StringToNum(theString, whole);						StandardForm := whole;					end;			end;	end;{--------------->     HandleFileChoice     <--}	procedure HandleFileChoice (theItem: INTEGER);		var			whichWindow: WindowPtr;	begin		case theItem of			NEW_ITEM: 				CreateWindow;			CLOSE_ITEM: 				begin					whichWindow := FrontWindow;					if whichWindow <> nil then						if IsDialogWindow(WindowPtr(gTheEvent.message)) then							DisposeDialog(whichWindow)						else							DisposeWindow(whichWindow);				end;			PAGE_SETUP_ITEM: 				PageSetup;			PRINT_ITEM: 				Print;			QUIT_ITEM: 				gDone := TRUE;		end;	end;{--------------->     HandleAppleChoice     <--}	procedure HandleAppleChoice (theItem: INTEGER);		var			accName: Str255;			accNumber, itemNumber: INTEGER;			aMenu: MenuHandle;	begin		case theItem of			ABOUT_ITEM: 				HandleAbout;			otherwise				begin					aMenu := GetMenuHandle(APPLE_MENU_ID);					GetMenuItemText(aMenu, theItem, accName);					accNumber := OpenDeskAcc(accName);				end;		end;	end;{--------------->     HandleMenuChoice     <--}	procedure HandleMenuChoice (menuChoice: LONGINT);		var			theMenu, theItem: INTEGER;	begin		if menuChoice <> 0 then			begin				theMenu := HiWord(menuChoice);				theItem := LoWord(menuChoice);				case theMenu of					APPLE_MENU_ID: 						HandleAppleChoice(theItem);					FILE_MENU_ID: 						HandleFileChoice(theItem);					EDIT_MENU_ID: 						HandleEditChoice(theItem);				end;				HiliteMenu(0);			end;	end;{--------------->     AdjustMenus     <--}	procedure AdjustMenus;		var			aMenu: MenuHandle;	begin		if FrontWindow = nil then			begin				aMenu := GetMenuHandle(FILE_MENU_ID);				DisableItem(aMenu, CLOSE_ITEM);				aMenu := GetMenuHandle(EDIT_MENU_ID);				DisableItem(aMenu, UNDO_ITEM);				DisableItem(aMenu, CUT_ITEM);				DisableItem(aMenu, COPY_ITEM);				DisableItem(aMenu, PASTE_ITEM);				DisableItem(aMenu, CLEAR_ITEM);				DisableItem(aMenu, COPY_RESULT_ITEM);			end		else			begin				aMenu := GetMenuHandle(FILE_MENU_ID);				EnableItem(aMenu, CLOSE_ITEM);			end;		aMenu := GetMenuHandle(EDIT_MENU_ID);		if IsDaWindow(FrontWindow) then			begin				EnableItem(aMenu, UNDO_ITEM);				EnableItem(aMenu, CUT_ITEM);				EnableItem(aMenu, COPY_ITEM);				EnableItem(aMenu, PASTE_ITEM);				EnableItem(aMenu, CLEAR_ITEM);				DisableItem(aMenu, COPY_RESULT_ITEM);			end		else			begin				DisableItem(aMenu, UNDO_ITEM);				EnableItem(aMenu, CUT_ITEM);				EnableItem(aMenu, COPY_ITEM);				EnableItem(aMenu, PASTE_ITEM);				EnableItem(aMenu, CLEAR_ITEM);				EnableItem(aMenu, COPY_RESULT_ITEM);			end;	end;{--------------->     HandleInput     <--}	procedure HandleInput (whichWindow: WindowPtr);		var			subsString: Str255;			sizeL: LongInt;			iType, item, result: Integer;			iHandle, point_handle, comma_handle, text_handle: Handle;			iRect: Rect;			myErr: OSErr;			caseData: CaseRecordHnd;	begin		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		subsString := DEC_POINT;		GetDialogItem(whichWindow, TSH_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, TSH_String);		TSH := StandardForm(TSH_String);		TSH := TSH * caseData^^.TSHUnitFactor;		TSH_String := StringOf(TSH : 1 : 2);		GetDialogItem(whichWindow, FT4_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, FT4_String);		FT4 := StandardForm(FT4_String);		FT4 := FT4 * UFT4;		FT4 := FT4 * caseData^^.FT4UnitFactor;		FT4_String := StringOf(FT4 / UFT4 : 1 : 2);		GetDialogItem(whichWindow, FT3_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, FT3_String);		FT3 := StandardForm(FT3_String);		FT3 := FT3 * UFT3;		FT3 := FT3 * caseData^^.FT3UnitFactor;		FT3_String := StringOf(FT3 / UFT3 : 1 : 2);		Calculate;		gMessageString := concat(gSignalString, kReturn, '   TSH: ', TSH_String, TSH_Unit, kReturn, '   FT4: ', FT4_String, FT4_Unit, kReturn, '   FT3: ', FT3_String, FT3_Unit);		gMessageString := concat(gMessageString, kReturn, gParameterString, kReturn, '   GT: ', GTs, kReturn, '   GD: ', GDs);		gMessageString := concat(gMessageString, kReturn, gRefExp, kReturn, gGTRef, kReturn, gGDRef);{SetWRefCon(whichWindow, longint(CaseData)); {entbehrlich?}		caseData^^.TSH := TSH;		caseData^^.FT4 := FT4;		caseData^^.FT3 := FT3;		caseData^^.GT := GT;		caseData^^.GD := GD;		caseData^^.MessageString := gMessageString;		HUnlock(Handle(CaseData));		ShowMessage(whichWindow);	end;{----------------> DoContentClick <--}	procedure DoContentClick (whichWindow: WindowPtr);		var			oldPort: GrafPtr;			origSize, origFont, item: Integer;			theDialog: DialogPtr;			thePoint, popUpUpperLeft: Point;			theChoice: longint;			caseData: CaseRecordHnd;	begin		GetPort(oldPort);		SetPort(whichWindow);		thePoint := gTheEvent.where;		GlobalToLocal(thePoint);		origSize := whichWindow^.txSize;		origFont := whichWindow^.txFont;		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		if IsDialogEvent(gTheEvent) then			begin				if DialogSelect(gTheEvent, theDialog, item) then					if item = CALCULATE_BUTTON then						HandleInput(whichWindow);				if PtInRect(thePoint, gTSHPopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gTSHPopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gTSHPopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gTSHPopUpRect);						theChoice := PopUpMenuSelect(caseData^^.TSHPopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.TSHPopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.TSHPopUpItem := LoWord(theChoice);								caseData^^.TSHUnitFactor := 1;							end;						DrawPopUpItems(whichWindow);						FrameRect(gTSHPopUpRect);					end; {if PtInRect}				if PtInRect(thePoint, gFT4PopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gFT4PopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gFT4PopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gFT4PopUpRect);						theChoice := PopUpMenuSelect(caseData^^.FT4PopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.FT4PopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.FT4PopUpItem := LoWord(theChoice);								case caseData^^.FT4PopUpItem of									1: 										caseData^^.FT4UnitFactor := 1;									2: 										caseData^^.FT4UnitFactor := 0.1;									4: 										caseData^^.FT4UnitFactor := 1 / UFT4 / 1e12;								end;							end;						DrawPopUpItems(whichWindow);						FrameRect(gFT4PopUpRect);					end; {if PtInRect}				if PtInRect(thePoint, gFT3PopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gFT3PopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gFT3PopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gFT3PopUpRect);						theChoice := PopUpMenuSelect(caseData^^.FT3PopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.FT3PopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.FT3PopUpItem := LoWord(theChoice);								case caseData^^.FT3PopUpItem of									1, 2: 										caseData^^.FT3UnitFactor := 1;									4: 										caseData^^.FT3UnitFactor := 1 / UFT3 / 1e12;								end;							end;						DrawPopUpItems(whichWindow);						FrameRect(gFT3PopUpRect);					end; {if PtInRect}			end;		HUnLock(Handle(CaseData));		TextSize(origSize);		TextFont(origFont);		SetPort(oldPort);	end;{----------------> HandleMouseDown <--}	procedure HandleMouseDown;		var			whichWindow: WindowPtr;			thePart: INTEGER;			menuChoice, windSize: LONGINT;	begin		thePart := FindWindow(gTheEvent.where, whichWindow);		case thePart of			inMenuBar: 				begin					menuChoice := MenuSelect(gTheEvent.where);					HandleMenuChoice(menuChoice);				end;			{inSysWindow: 				SystemClick(gTheEvent, whichWindow);}			inDrag: 				DragWindow(whichWindow, gTheEvent.where, GetGrayRgn^^.rgnBBox);			inGoAway: 				if TrackGoAway(whichWindow, gTheEvent.where) then					if IsDialogWindow(WindowPtr(gTheEvent.message)) then						DisposeDialog(whichWindow)					else						DisposeWindow(whichWindow);			inContent: 				if whichWindow <> FrontWindow then					SelectWindow(whichWindow)				else					DoContentClick(whichWindow);		end;	end;{----------------> HandleKeyDown <--}	procedure HandleKeyDown;		var			key: Char;			iType, item: Integer;			iHandle: Handle;			iRect: Rect;			finalTicks: UInt32;			handled: Boolean;			theDialog: DialogPtr;	begin		handled := FALSE;		theDialog := FrontWindow;		key := Char(BAnd(gTheEvent.message, charCodeMask));		if (key = char(kRETURN)) or (key = char(kENTER)) then			begin				if theDialog <> nil then					begin						SetPort(theDialog);						GetDialogItem(theDialog, CALCULATE_BUTTON, iType, iHandle, iRect);						HiliteControl(ControlHandle(iHandle), inButton);						Delay(kVISUAL, finalTicks);						HiliteControl(ControlHandle(iHandle), 0);						HandleInput(theDialog);						handled := TRUE;					end				else					begin						item := NoteAlert(RES_BASE + 10, nil);						handled := true;					end;			end;		if (BitAnd(gTheEvent.modifiers, cmdKey) <> 0) then			begin				AdjustMenus;				HandleMenuChoice(MenuKey(key));				handled := TRUE;			end;		if not handled then			if theDialog <> nil then				begin					if validkey(key) then						handled := DialogSelect(gTheEvent, theDialog, item);				end			else				item := NoteAlert(RES_BASE + 10, nil);	end;{----------------> HandleEvent <--}	procedure HandleEvent;		var			theChar: CHAR;			gotEvent, result: BOOLEAN;			oldPort: GrafPtr;			window: WindowPtr;			iHit, state: Integer;			control: ControlHandle;			iType, item: integer;			iHandle: Handle;			iRect: Rect;	begin		{if gWNEImplemented then}			gotEvent := WaitNextEvent(everyEvent, gTheEvent, MIN_SLEEP, nil)		{else			begin				SystemTask;				gotEvent := GetNextEvent(everyEvent, gTheEvent);			end};		if gotEvent then			case gTheEvent.what of				mouseDown: 					begin						AdjustMenus;						HandleMouseDown;					end;				keyDown, autoKey: 					begin						HandleKeyDown;					end;				activateEvt: 					begin						state := BAnd(gTheEvent.modifiers, activeFlag);						if (IsDialogWindow(WindowPtr(gTheEvent.message))) and (WindowPtr(gTheEvent.message) <> gAboutDialog) then							begin								control := controlHandle(WindowPeek(WindowPtr(gTheEvent.message))^.controlList);								while control <> nil do									begin										HiliteControl(control, state + 255 mod 256);										control := control^^.nextControl;										GetDialogItem(WindowPtr(gTheEvent.message), CALCULATE_BUTTON, iType, iHandle, iRect);										DoOutlineControl(iHandle);{result := DialogSelect(gTheEvent, WindowPtr(gTheEvent.message), item);}									end;							end;					end;				updateEvt: 					if not IsDAWindow(WindowPtr(gTheEvent.message)) then						begin							AdjustMenus;							GetPort(oldPort);							SetPort(WindowPtr(gTheEvent.message));							BeginUpdate(WindowPtr(gTheEvent.message));							UpdateDialog(WindowPtr(gTheEvent.message), WindowPtr(gTheEvent.message)^.visRgn);							ShowMessage(WindowPtr(gTheEvent.message));							EndUpdate(WindowPtr(gTheEvent.message));							GetDialogItem(WindowPtr(gTheEvent.message), CALCULATE_BUTTON, iType, iHandle, iRect);							DoOutlineControl(iHandle);							DrawPopUps(WindowPtr(gTheEvent.message));							SetPort(oldPort);						end;				nullEvent: 					begin						window := FrontWindow;						if IsDialogWindow(FrontWindow) then							result := DialogSelect(gTheEvent, window, item);					end;			end		else			begin				window := FrontWindow;				if IsDialogWindow(FrontWindow) then					result := DialogSelect(gTheEvent, window, item);			end;	end;{----------------> MainLoop <--}	procedure MainLoop;	begin		gDone := FALSE;		gWNEImplemented := (NGetTrapAddress(WNE_TRAP_NUM, ToolTrap) <> NGetTrapAddress(UNIMPL_TRAP_NUM, ToolTrap));		while (gDone = FALSE) do			HandleEvent;{PrClose;}	end;{----------------> MenuBarInit <--}	procedure MenuBarInit;		var			myMenuBar: Handle;			aMenu: MenuHandle;	begin		myMenuBar := GetNewMBar(RES_BASE);		if myMenuBar = nil then			ErrorHandler(NO_MBAR);		SetMenuBar(myMenuBar);{--- DisposeHandle(myMenuBar); ---}		aMenu := GetMenuHandle(APPLE_MENU_ID);		if aMenu = nil then			ErrorHandler(NO_MENU);		AppendResMenu(aMenu, 'DRVR');		aMenu := GetMenu(EDIT_MENU_ID);		if aMenu = nil then			ErrorHandler(NO_MENU);		aMenu := GetMenu(FILE_MENU_ID);		if aMenu = nil then			ErrorHandler(NO_MENU);		DrawMenuBar;	end;{----------------> SPINA-Thyr <--}begin	MaxApplZone;	MoreMasters;	InitGraf(@qd.thePort);	InitFonts;	InitWindows;	InitMenus;	TEInit;	InitDialogs(nil);	MenuBarInit;	gSplashDialog := GetNewDialog(RES_BASE + 3, nil, WindowPtr(-1));	SelectWindow(gSplashDialog);	ShowWindow(gSplashDialog);	SetPort(gSplashDialog);	DrawDialog(gSplashDialog);	PrintInit;	gNewWindowLeft := WINDOW_HOME_LEFT;	gNewWindowTop := WINDOW_HOME_TOP;	gcalcCounter := 0;	SetRect(gMessageRect, 8, 110, 150, 240);	GetIndString(gnotcalculatableString, RES_BASE, 1);	GetIndString(gExplanationString, RES_BASE, 2);	GetIndString(gRefExp, RES_BASE, 3);	GetIndString(gGTRef, RES_BASE, 4);	GetIndString(gGDRef, RES_BASE, 5);	GetIndString(gSignalString, RES_BASE, 6);	GetIndString(gParameterString, RES_BASE, 7);	GetIndString(gPatName, RES_BASE + 1, 1);	GetIndString(gPatBirthday, RES_BASE + 1, 2);	GetIndString(gPatSender, RES_BASE + 1, 3);	GetIndString(gPrintingDate, RES_BASE + 1, 4);	GetIndString(gChooserName, RES_BASE + 1, 5);	GetIndString(gExaminationDate, RES_BASE + 1, 6);	Delay(30, gfinalTicks);	HideWindow(gSplashDialog);	CreateWindow;	MainLoop;end.