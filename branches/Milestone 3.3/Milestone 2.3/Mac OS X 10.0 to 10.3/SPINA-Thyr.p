{            SPINA-Thyr           }{ Programm zur Berechnung }{  von  Strukturparametern  }{        des thyreotropen        }{            Regelkreises           }{		  Version 2.3		   }{J. W. Dietrich, Klinikum Innenstadt der LMU München 1997-2002}program SPINAThyr;	uses	{Types, QuickDraw, OSUtils, SegLoad, Fonts, Windows, MacWindows, Menus, Traps,	TextEdit, Dialogs, Processes, Events, QuickDrawText, Controls, Lists, Packages, 	Memory, Strings, Resources, Scrap, Sound, Devices, ControlDefinitions, CarbonEvents,	ToolUtils, Script, Printing, CoreServices, GestaltEqu, Appearance, CarbonBridge;}	Types, OSUtils, ToolUtils, QuickDraw, SegLoad, Fonts, Windows, MacWindows, Events,    Menus, TextEdit, Dialogs, Resources, Controls, SegLoad, Memory, AppleEvents, AERegistry,     Processes, QuickDrawText, Sound, TextUtils, CoreServices, CarbonBridge;	const		RES_BASE = 400;		APPLE_MENU_ID = 400;		FILE_MENU_ID = 401;		EDIT_MENU_ID = 402;		TSH_POPUP_MENU_ID = 410;		FT4_POPUP_MENU_ID = 411;		FT3_POPUP_MENU_ID = 412;		NOT_A_NORMAL_MENU = -1;		ABOUT_ITEM = 1;		ABOUT_ALERT = 400;		ERROR_ALERT_ID = 401;		NO_MBAR = RES_BASE;		NO_MENU = RES_BASE + 1;		NO_PICTURE = RES_BASE + 2;		NO_WIND = RES_BASE + 3;		NO_TEXT = RES_BASE + 4;		NO_MEMORY = RES_BASE + 5;		NEW_ITEM = 1;		CLOSE_ITEM = 2;		PAGE_SETUP_ITEM = 4;		PRINT_ITEM = 5;		QUIT_ITEM = 7;		UNDO_ITEM = 1;		CUT_ITEM = 3;		COPY_ITEM = 4;		PASTE_ITEM = 5;		CLEAR_ITEM = 6;		COPY_RESULT_ITEM = 8;		POPUP_LEFT = 120;		POPUP_TOP = 190;		POPUP_RIGHT = 180;		POPUP_BOTTOM = 207;		SHADOW_PIXELS = 1;		RIGHT_MARGIN = 20;		BOTTOM_MARGIN = 4;		LEFT_MARGIN = 5;		PIXEL_FOR_TOP_LINE = 1;		POPUP_SIZE = 9;		ABOUT_OK_BUTTON = 1;		CALCULATE_BUTTON = 1;		EDGE_THRESHOLD = 30;		WINDOW_HOME_LEFT = 15;		WINDOW_HOME_TOP = 55;		NEW_WINDOW_OFFSET = 20;		ACTIVATING = 1;		CONTROL_ACTIVATE = 0;		CONTROL_DEACTIVATE = $FF;		ON = 1;		OFF = 0;		MIN_SLEEP = 60;		LEAVE_WHERE_IT_IS = FALSE;		WNE_TRAP_NUM = $60;		UNIMPL_TRAP_NUM = $9F;		PAGE_MARGIN = 30;		NIL_STRING = '';		HOPELESSLY_FATAL_ERROR = 'Der Ressourcenzweig ist beschädigt.';		kENTER = char(3);		kTAB = char(9);		kRETURN = char(13);		kESCAPE = char(27);		kPERIOD = '.';		kVisual = 8;		inButton=10;		inCheckBox=11;		inUpButton=20;		{inDownButton=21;}		inThumb=129;		DEC_POINT = '.';		DEC_COMMA = ',';		TEXT_WIDTH = 10;		TSH_Unit = ' mU/l';		FT4_Unit = ' ng/dl';		FT3_Unit = ' pg/ml';		TSH_Text = 2;		FT4_Text = 3;		FT3_Text = 4;		TSH_Unit_Item = 7;		FT4_Unit_Item = 9;		FT3_Unit_Item = 8;		UFT4 = 1.28e-11;		UFT3 = 1.54e-12;		ALPHAT = 0.1;		BETAT = 1.1e-6;		THY = 1;		I = 1;		DT = 2.75;		KT = 1;		KI = 1;		TBG = 3e-7;		TBPA = 4.5e-6;		K30 = 2e9;		K41 = 2e10;		K42 = 2e8;		ALPHA31 = 0.026;		BETA31 = 8e-6;		KM1 = 5e-7;	type		CaseRecord = record			TSH, FT4, FT3, GT, GD: real;			TSHUnitFactor, FT4UnitFactor, FT3UnitFactor: real;			TSHPopUpItem, FT4PopUpItem, FT3PopUpItem: integer;			TSHPopUpMenu, FT4PopUpMenu, FT3PopUpMenu: MenuHandle;			MessageString: Str255;		end;		CaseRecordPtr = ^CaseRecord;		CaseRecordHnd = ^CaseRecordPtr;	var		TSH, FT4, FT3, GT, GD: real;		gDone, gWNEImplemented: Boolean;		gTheEvent: EventRecord;		gNewWindowLeft, gNewWindowTop: integer;		gTSHPopUpRect, gFT4PopUpRect, gFT3PopUpRect: Rect;		gAboutDialog, gSplashDialog: DialogPtr;		gCalcButton: ControlHandle;		gMessageRect: Rect;		gcalcTitle, gcalcString, gnotcalculatableString, GTs, GDs: Str255;		gExplanationString, gMessageString, TSH_String, FT4_String, FT3_String: Str255;		gRefExp, gGTRef, gGDRef, gSignalString, gParameterString: Str255;		gPatName, gPatBirthday, gPatSender, gChooserName, gPrintingDate, gExaminationDate: Str255;		gcalcCounter: longint;		gPrintRecordH: THPrint;		gfinalTicks:UInt32;		gDoOpenAppEventUPP : AEEventHandlerUPP;		gDoReopenAppEventUPP : AEEventHandlerUPP; 		gDoOpenDocsEventUPP : AEEventHandlerUPP; 		gDoPrintDocsEventUPP : AEEventHandlerUPP; 		gDoQuitAppEventUPP : AEEventHandlerUPP; 		gRgn:RgnHandle;function StringOfLong (theNum:longint):Str255;vartheString:Str255;beginNumToString(theNum,theString);StringOfLong:=theString;end; procedure DisplayDialog (defaultString: str255);  var   iRect: Rect;   iHandle: Handle;   iType, itemHit, ignore: integer;   theDialog: DialogPtr;   theString: str255;   theErr: OSErr; begin  if defaultString <> '' then   theString := defaultString  else   theString := '<>';   ParamText(theString, NIL_STRING, NIL_STRING, NIL_STRING);   theErr := NoteAlert(ERROR_ALERT_ID+1, nil); end;{----------------> ErrorHandler <--}	procedure ErrorHandler (stringNum: INTEGER);		var			errorStringH: StringHandle;			result: INTEGER;	begin		errorStringH := GetString(stringNum);		if errorStringH = nil then			ParamText(HOPELESSLY_FATAL_ERROR, NIL_STRING, NIL_STRING, NIL_STRING)		else			ParamText(errorStringH^^, NIL_STRING, NIL_STRING, NIL_STRING);		result := StopAlert(ERROR_ALERT_ID, nil);		ExitToShell;	end;{--------------->     IsDAWindow     <--}	function IsDAWindow (whichWindow: WindowPtr): BOOLEAN;	begin		if whichWindow = nil then			isDaWindow := FALSE		else{$IF TARGET_API_MAC_CARBON}            isDaWindow := FALSE;{$ELSE}			IsDaWindow := (WindowPeek(whichWindow)^.windowKind < 0);{$ENDIF}	end;{--------------->     IsDialogWindow     <--}	function IsDialogWindow (theWindow: WindowPtr): Boolean;	begin		if theWindow = nil then			IsDialogWindow := FALSE		else			IsDialogWindow := GetWindowKind(theWindow) = dialogKind;	end;{----------------> PrintInit <--}	procedure PrintInit;	var		theErr:OSErr;	begin		{$IF NOT TARGET_API_MAc_CARBON}		PrOpen;		gPrintRecordH := THPrint(NewHandle(sizeof(TPrint)));		PrintDefault(gPrintRecordH);		prClose;		{$ENDIF}	end;{----------------> PageSetup <--}	procedure PageSetup;		var			keepGoing: boolean;	begin		{$IF NOT TARGET_API_MAc_CARBON}		prOpen;		keepGoing := PrStlDialog(gPrintRecordH);		prClose;		{$ENDIF}	end;{----------------> Print <--}	procedure Print;		var			keepGoing: boolean;			thePict: PicHandle;			theWindow: WindowPtr;			printPort: TPPrPort;			printStatus: TPPrStatusRef;			origFont, origSize: INTEGER;			oldPort: GrafPtr;			DrawingRect, tempRect: Rect;			caseData: CaseRecordHnd;			theString, chooserString, dateString: Str255;			currentTime: UInt32;	begin		{$IF NOT TARGET_API_MAc_CARBON}		theWindow := frontWindow;		if IsDialogWindow(theWindow) then			begin				prOpen;				keepGoing := PrJobDialog(gPrintRecordH);				if keepGoing then					begin						with DrawingRect do							begin								left := gPrintRecordH^^.prInfo.rPage.left + 2 * PAGE_MARGIN;								top := gPrintRecordH^^.prInfo.rPage.top + PAGE_MARGIN;								right := gPrintRecordH^^.prInfo.rPage.right - PAGE_MARGIN;								bottom := gPrintRecordH^^.prInfo.rPage.bottom - PAGE_MARGIN;							end;						tempRect := DrawingRect;						thePict := GetPicture(RES_BASE + 2);						if thePict = nil then							ErrorHandler(NO_PICTURE);						with thePict^^.picFrame do							begin								tempRect.right := tempRect.left + (right - left) div 2;								tempRect.bottom := tempRect.top + (bottom - top) div 2;							end;						GetPort(oldPort);						HLock(Handle(thePict));						printPort := TPPrPort(PrOpenDoc(gPrintRecordH, nil, nil));						if(OSErr(PrError) = noErr) then						PrOpenPage(pointer(printPort), nil);						if(OSErr(PrError) = noErr) then						begin							DrawPicture(thePict, tempRect);							MoveTo(tempRect.left, tempRect.bottom + 5);							LineTo(DrawingRect.right, tempRect.bottom + 5);							origFont := GetPortTextFont(GetWindowPort(theWindow));							origSize := GetPortTextSize(GetWindowPort(theWindow));							TextFont(applFont);							TextSize(10);							with tempRect do								begin									top := bottom + 30;									right := DrawingRect.right;									bottom := top + 3 * 10 * 2;								end;							theString := concat(gPatName, kReturn, gPatBirthday, kReturn, gPatSender, kReturn, gExaminationDate);							TETextBox(Pointer(ord(@theString) + 1), length(theString), tempRect, teFlushLeft);							with tempRect do								begin									top := bottom + 10;									right := DrawingRect.right;									bottom := top + gMessageRect.bottom - gMessageRect.top;								end;							caseData := CaseRecordHnd(GetWRefCon(theWindow));							if caseData = nil then								ErrorHandler(NO_MEMORY);							HLock(Handle(CaseData));							theString := caseData^^.MessageString;							HUnlock(Handle(CaseData));							TETextBox(Pointer(ord(@theString) + 1), length(theString), tempRect, teFlushLeft);							MoveTo(DrawingRect.left, DrawingRect.bottom - 20);							chooserString := Str255(GetString(-16096)^^);							GetDateTime(currentTime);							IUDateString(currentTime, 1, dateString);							theString := concat(gChooserName, chooserString, ' • ', gPrintingDate, dateString);							DrawString(theString);							TextFont(origFont);							TextSize(origSize);							PrClosePage(pointer(printPort));						end;						PrCloseDoc(pointer(printPort));						if ((gPrintRecordH^^.prJob.bJDocLoop = bSpoolLoop) and (PrError = noErr)) then							PrPicFile(gPrintRecordH, nil, nil, nil, printStatus);						HUnlock(Handle(thePict));						SetPort(oldPort);						prClose;					end;			end;			{$ENDIF}	end;			{----------------> AppleEvent-Handlers <--} function GotRequiredParams (theAppleEvent: AppleEvent): OSErr;    (* standard AppleEvent routine copied out of NIM:IAC *) var   typeCode: DescType;   actualSize: Size;   err: OSErr; begin   err := AEGetAttributePtr(theAppleEvent,   keyMissedKeywordAttr, typeWildCard,   typeCode, nil, 0, actualSize); if err = errAEDescNotFound then begin   GotRequiredParams := noErr; end else if err = noErr then begin   GotRequiredParams := errAEEventNotHandled; end else begin   GotRequiredParams := err; end; (* if *) end; (* GotRequiredParams *) function DoQuitEvent(theAppleEvent,reply:AppleEvent;refcon:longint):OSErr; var   theErr:OSErr; begin   theErr:=GotRequiredParams(theAppleEvent);   gDone:=true;   DoQuitEvent:=noErr; end; function HandleOpenApplicationEvent(theAppleEvent,reply:AppleEvent;refcon:longint):OSErr; var   theErr:OSErr; begin   theErr:=GotRequiredParams(theAppleEvent);   HandleOpenApplicationEvent:=theErr; end;{----------------> DrawPopUpItems <--}	procedure DrawPopUpItems (theWindow: WindowPtr);		var			menuItem: Str255;			ItemLeftMargin, arrowHeight, arrowWidth: integer;			caseData: CaseRecordHnd;			theArrow: PicHandle;			arrowRect: Rect;	begin		theArrow := GetPicture(RES_BASE + 10);		arrowHeight := theArrow^^.picFrame.bottom - theArrow^^.picFrame.top;		arrowWidth := theArrow^^.picFrame.right - theArrow^^.picFrame.left;		caseData := CaseRecordHnd(GetWRefCon(theWindow));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		GetMenuItemText(caseData^^.TSHPopUpMenu, caseData^^.TSHPopUpItem, menuItem);		ItemLeftMargin := (gTSHPopUpRect.right - gTSHPopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gTSHPopUpRect;		with arrowRect do			begin				top := gTSHPopUpRect.top + 6;				right := gTSHPopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gTSHPopUpRect.left + itemLeftMargin, gTSHPopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		GetMenuItemText(caseData^^.FT4PopUpMenu, caseData^^.FT4PopUpItem, menuItem);		ItemLeftMargin := (gFT4PopUpRect.right - gFT4PopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gFT4PopUpRect;		with arrowRect do			begin				top := gFT4PopUpRect.top + 6;				right := gFT4PopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gFT4PopUpRect.left + itemLeftMargin, gFT4PopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		GetMenuItemText(caseData^^.FT3PopUpMenu, caseData^^.FT3PopUpItem, menuItem);		ItemLeftMargin := (gFT3PopUpRect.right - gFT3PopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gFT3PopUpRect;		with arrowRect do			begin				top := gFT3PopUpRect.top + 6;				right := gFT3PopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gFT3PopUpRect.left + itemLeftMargin, gFT3PopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		HUnlock(Handle(CaseData));	end;{----------------> DrawPopUps <--}	procedure DrawPopUps (theWindow: WindowPtr);		var			origSize, origFont: integer;			iType: integer;			iHandle: Handle;			iRect: Rect;	begin		origSize := GetPortTextSize(GetWindowPort(theWindow));		origFont := GetPortTextFont(GetWindowPort(theWindow));		TextSize(POPUP_SIZE);		TextFont(applFont);		GetDialogItem(GetDialogFromWindow(theWindow), TSH_Unit_Item, iType, iHandle, iRect);		gTSHPopUpRect := iRect;		FrameRect(gTSHPopUpRect);		with gTSHPopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		GetDialogItem(GetDialogFromWindow(theWindow), FT4_Unit_Item, iType, iHandle, iRect);		gFT4PopUpRect := iRect;		FrameRect(gFT4PopUpRect);		with gFT4PopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		GetDialogItem(GetDialogFromWindow(theWindow), FT3_Unit_Item, iType, iHandle, iRect);		gFT3PopUpRect := iRect;		FrameRect(gFT3PopUpRect);		with gFT3PopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		DrawPopUpItems(theWindow);		TextSize(origSize);		TextFont(origFont);	end;{----------------> PopUpMenuInit <--}	procedure PopUpMenuInit (whichWindow: WindowPtr);		var			caseData: CaseRecordHnd;	begin		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		caseData^^.TSHPopUpMenu := GetMenu(TSH_POPUP_MENU_ID);		InsertMenu(caseData^^.TSHPopUpMenu, NOT_A_NORMAL_MENU);		caseData^^.TSHPopUpItem := 1;		caseData^^.TSHUnitFactor := 1;		caseData^^.FT4PopUpMenu := GetMenu(FT4_POPUP_MENU_ID);		InsertMenu(caseData^^.FT4PopUpMenu, NOT_A_NORMAL_MENU);		caseData^^.FT4PopUpItem := 1;		caseData^^.FT4UnitFactor := 1;		caseData^^.FT3PopUpMenu := GetMenu(FT3_POPUP_MENU_ID);		InsertMenu(caseData^^.FT3PopUpMenu, NOT_A_NORMAL_MENU);		caseData^^.FT3PopUpItem := 1;		caseData^^.FT3UnitFactor := 1;		HUnlock(Handle(CaseData));	end;{--------------->     ShowMessage     <--}	procedure ShowMessage (theWindow: WindowPtr);		var			origFont, origSize: INTEGER;			theString: Str255;			caseData: CaseRecordHnd;			oldPort: GrafPtr;			theRefCon:longint;	begin		if theWindow <> nil then			begin				GetPort(oldPort);				SetPort(GetWindowPort(theWindow));				theRefCon:=GetWRefCon(theWindow);				if theRefCon<>0 then				begin					caseData := CaseRecordHnd(theRefCon);					if caseData = nil then						ErrorHandler(NO_MEMORY);					HLock(Handle(CaseData));					theString := caseData^^.MessageString;					HUnlock(Handle(CaseData));					origFont := GetPortTextFont(GetWindowPort(theWindow));					origSize := GetPortTextSize(GetWindowPort(theWindow));					TextFont(applFont);					TextSize(10);					TETextBox(Pointer(ord(@theString) + 1), length(theString), gMessageRect, teFlushLeft);					TextFont(origFont);					TextSize(origSize);				end;				SetPort(oldPort);			end;	end;{--------------->     DoOutlineControl     <--}	procedure DoOutlineControl (theControl: univ ControlHandle; theItem:integer);		var			theOval: INTEGER;			theRect: Rect;			origPen: PenState;			oldPort: GrafPtr;			theWindow: WindowPtr;			theErr: OSErr;	begin{$IF TARGET_API_MAC_CARBON}		if theControl <> nil then			begin				theWindow:=GetControlOwner(theControl);				GetPort(oldPort);				SetPort(GetWindowPort(theWindow));				{theErr:=SetWindowDefaultButton(theWindow,theControl);}				theErr:=SetDialogDefaultItem(GetDialogFromWindow(theWindow),theItem);				SetPort(oldPort);			end;{$ELSE}		if theControl <> nil then			begin				GetPort(oldPort);				SetPort(GetWindowPort(GetControlOwner(theControl)));				GetPenState(origPen);				PenNormal;				theRect := theControl^^.contrlRect;				InsetRect(theRect, -4, -4);				theOval := ((theRect.bottom - theRect.top) div 2) + 2;				if (theControl^^.contrlHilite = CONTROL_ACTIVATE) then					PenPat(qd.black)				else					PenPat(qd.gray);				PenSize(3, 3);				FrameRoundRect(theRect, theOval, theOval);				SetPenState(origPen);				SetPort(oldPort);			end;{$ENDIF}	end;{--------------->      Calculate     <--}	procedure Calculate;	begin		if TSH > 0 then			begin				GT := betaT * (DT + TSH) * (1 + k41 * TBG + k42 * TBPA) * FT4 / (alphaT * TSH);				GTs := concat(StringOf(1e12 * GT : 5 : 2), ' pmol/s');			end		else			GTs := gnotcalculatableString;		if FT4 > 0 then			begin				GD := beta31 * (kM1 + FT4) * (1 + k30 * TBG) * FT3 / (alpha31 * FT4);				GDs := concat(StringOf(1e9 * GD : 5 : 2), ' nmol/s');			end		else			GDs := gnotcalculatableString;	end;{--------------->      CenterPict     <--}	procedure CenterPict (thePicture: PicHandle; var myRect: Rect);		var			windRect, pictureRect: Rect;	begin		WindRect := myRect;		pictureRect := thePicture^^.picFrame;		myRect.top := (windRect.bottom - windRect.top - (pictureRect.bottom - pictureRect.top)) div 2 + windRect.top;		myRect.bottom := myRect.top + (pictureRect.bottom - pictureRect.top);		myRect.left := (windRect.right - windRect.left - (pictureRect.right - pictureRect.left)) div 2 + windRect.left;		myRect.right := myRect.left + (pictureRect.right - pictureRect.left);	end;{--------------->     DrawPictures     <--}	procedure DrawPictures (pictureWindow: WindowPtr);		var			myRect: Rect;			thePicture: picHandle;	begin		myRect := GetPortBounds(GetWindowPort(pictureWindow),myRect)^;		thePicture := GetPicture(RES_BASE + 1);		if thePicture = nil then			ErrorHandler(NO_PICTURE);		SetRect(myRect, 126, 19, 371, 236);		SetPort(GetWindowPort(pictureWindow));		DrawPicture(thePicture, myRect);		thePicture := GetPicture(RES_BASE + 2);		if thePicture = nil then			ErrorHandler(NO_PICTURE);		SetRect(myRect, 8, 39, 135, 104);		SetPort(GetWindowPort(pictureWindow));		DrawPicture(thePicture, myRect);	end;{--------------->     CreateWindow     <--}	procedure CreateWindow;		var			theNewestWindow: DialogPtr;			oldPort: GrafPtr;			iType: integer;			iHandle: Handle;			iRect: Rect;			caseData: CaseRecordHnd;			ScreenBits:Bitmap;			theRefCon:longint;	begin		theNewestWindow := GetNewDialog(RES_BASE + 1, nil, WindowPtr(-1));		if theNewestWindow = nil then			ErrorHandler(NO_WIND);		screenBits:=GetQDGlobalsScreenBits(screenBits)^;		if ((screenBits.bounds.right - gNewWindowLeft) < EDGE_THRESHOLD) or ((screenBits.bounds.bottom - gNewWindowTop) < EDGE_THRESHOLD) then		begin			gNewWindowLeft := WINDOW_HOME_LEFT;			gNewWindowTop := WINDOW_HOME_TOP;		end;		gcalcTitle := 'Berechnung';		gcalcCounter := gcalcCounter + 1;		if gcalcCounter > 1 then			begin				NumToString(gcalcCounter, gcalcString);				gcalcTitle := concat(gcalcTitle, ' ', gcalcString);			end;		SetWTitle(GetDialogWindow(theNewestWindow), gcalcTitle);		gMessageString := gExplanationString;		caseData := CaseRecordHnd(NewHandle(sizeof(CaseRecord)));		if caseData = nil then			ErrorHandler(NO_MEMORY);		SetWRefCon(GetDialogWindow(theNewestWindow),longint(CaseData));		HLock(Handle(CaseData));		caseData^^.TSH := TSH;		caseData^^.FT4 := FT4;		caseData^^.FT3 := FT3;		caseData^^.GT := GT;		caseData^^.GD := GD;		caseData^^.MessageString := gMessageString;		HUnlock(Handle(CaseData));		MoveWindow(GetDialogWindow(theNewestWindow), gNewWindowLeft, gNewWindowTop, LEAVE_WHERE_IT_IS);		gNewWindowLeft := gNewWindowLeft + NEW_WINDOW_OFFSET;		gNewWindowTop := gNewWindowTop + NEW_WINDOW_OFFSET;		GetDialogItem(theNewestWindow, TSH_Text, iType, iHandle, iRect);		SetDialogItemText(iHandle, '0');		SelectDialogItemText(theNewestWindow, TSH_Text, 0, 32767);		GetPort(oldPort);		{$IF TARGET_API_MAC_CARBON}		SetPortDialogPort(theNewestWindow);		{$ELSE}		SetPort(GetWindowPort(WindowPtr(theNewestWindow)));		{$ENDIF}		ShowWindow(GetDialogWindow(theNewestWindow));		ShowMessage(GetDialogWindow(theNewestWindow));		GetDialogItem(theNewestWindow, CALCULATE_BUTTON, iType, iHandle, iRect);		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);		DoOutlineControl(iHandle, CALCULATE_BUTTON);		PopUpMenuInit(GetDialogWindow(theNewestWindow));		SetPort(oldPort);	end;{--------------->      ShowSplash  <--}	procedure ShowSplash;		var			iHit, iType, theTabulator: INTEGER;			iRect, aboutRect: Rect;			iHandle: Handle;			dialogDone: BOOLEAN;			theErr:OSErr;	begin		if gSplashDialog = nil then			gSplashDialog := GetNewDialog(RES_BASE+3, nil, WindowPtr(-1));		SelectWindow(GetDialogWindow(gSplashDialog));		ShowWindow(GetDialogWindow(gSplashDialog));		{$IF TARGET_API_MAC_CARBON}		SetPortDialogPort(gSplashDialog);		{$ELSE}		SetPort(GetWindowPort(GetDialogWindow(gSplashDialog)));		{$ENDIF}		{$IF TARGET_API_MAC_CARBON}		dialogDone := FALSE;		while DialogDone = FALSE do			begin				theErr:=SetDialogTimeout(gSplashDialog,1,1);				ModalDialog(nil, iHit);				DialogDone:=TRUE;			end;		{$ELSE}				Delay(30, gfinalTicks);		{$ENDIF}	end;{--------------->      HandleAbout     <--}	procedure HandleAbout;		var			iHit, iType, theTabulator: INTEGER;			iRect, aboutRect: Rect;			iHandle: Handle;			dialogDone: BOOLEAN;	begin		if gAboutDialog = nil then			gAboutDialog := GetNewDialog(RES_BASE, nil, WindowPtr(-1));		SelectWindow(GetDialogWindow(gAboutDialog));		ShowWindow(GetDialogWindow(gAboutDialog));		{$IF TARGET_API_MAC_CARBON}		SetPortDialogPort(gAboutDialog);		{$ELSE}		SetPort(GetWindowPort(GetDialogWindow(gAboutDialog)));		{$ENDIF}		{aboutRect := GetPortBounds(GetWindowPort(GetDialogWindow(gAboutDialog)),aboutRect)^;}		GetDialogItem(gAboutDialog, ABOUT_OK_BUTTON, iType, iHandle, iRect);		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);		DoOutlineControl(iHandle, ABOUT_OK_BUTTON);		dialogDone := FALSE;		while DialogDone = FALSE do			begin				ModalDialog(nil, iHit);				case iHit of					ABOUT_OK_BUTTON: 						begin							HideWindow(GetDialogWindow(gAboutDialog));							dialogDone := TRUE;						end;				end;			end;	end;{--------------->     HandleCopyResult     <--}	procedure HandleCopyResult (theDialog: DialogPtr);		var			caseData: CaseRecordHnd;			theString: Str255;			ResultPtr: Ptr;			thelength: LongInt;	begin		caseData := CaseRecordHnd(GetWRefCon(GetDialogWindow(theDialog)));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		theString := caseData^^.MessageString;		HUnlock(Handle(CaseData));		thelength := length(theString);		ResultPtr := NewPtr(thelength);		ResultPtr := Ptr(ord(@theString) + 1);		if ZeroScrap <> noErr then			ErrorHandler(NO_MEMORY)		else if PutScrap(thelength, 'TEXT', ResultPtr) <> noErr then			ErrorHandler(NO_MEMORY);		DisposePtr(ResultPtr);	end;{--------------->     HandleEditChoice     <--}	procedure HandleEditChoice (theItem: INTEGER);		var			result: Boolean;			theDialog: DialogPtr;			iErr: OSErr;	begin		if IsDialogWindow(frontWindow) then			begin				theDialog := GetDialogFromWindow(frontWindow);				case theItem of					CUT_ITEM: 						begin							DialogCut(theDialog);							if ZeroScrap = noErr then								iErr := TEToScrap;						end;					COPY_ITEM: 						begin							DialogCopy(theDialog);							if ZeroScrap = noErr then								iErr := TEToScrap;						end;					PASTE_ITEM: 						begin							iErr := TEFromScrap;							DialogPaste(theDialog);						end;					CLEAR_ITEM: 						DialogDelete(theDialog);					COPY_RESULT_ITEM: 						HandleCopyResult(theDialog);					otherwise						result := SystemEdit(theItem - 1);				end;			end		else			result := SystemEdit(theItem - 1);	end;{--------------->     NumberForm     <--}	function NumberForm (compos: integer; theString: Str255): extended;	{Wandelt String in Fließkommazahl um}		var			num, wholeS, remainderS: Str255;			whole, remainder: longint;	begin		wholeS := copy(theString, 1, compos-1);		StringToNum(wholeS, whole);		remainderS := copy(theString, compos + 1, (length(theString) - compos));		StringToNum(remainderS, remainder);		NumberForm := whole + remainder / exp(ln(10) * length(remainderS));	end;{--------------->     ValidKey     <--}	function ValidKey (theKey: char): boolean;	{Beschränkt Texteingabe auf zulässige Zeichen}		type			format1 = set of char;		var			theformatn, theformatd, theformate, theformato, theformatc, thevalidformat: format1;	begin		ValidKey := false;		theformatn := ['1'..'9', '0', kTAB];		theformatd := ['.', ','];		theformate := ['e', 'E'];		theformato := ['+', '-'];		theformatc := [char($1c), char($1d), char($1e), char($1f), char($08)];		thevalidformat := theformatn + theformatd + theformate + theformatc;		if thekey in thevalidformat then			ValidKey := true		else			SysBeep(30);	end;{--------------->     StandardForm     <--}	function StandardForm (theString: Str255): extended;		var			compos: integer;			num, wholeS, remainderS: Str255;			whole, remainder: longint;	begin		compos := pos(DEC_COMMA, theString);		if compos > 0 then			StandardForm := NumberForm(compos, theString)		else			begin				compos := pos(DEC_POINT, theString);				if compos > 0 then					StandardForm := NumberForm(compos, theString)				else					begin						StringToNum(theString, whole);						StandardForm := whole;					end;			end;	end;{--------------->     HandleFileChoice     <--}	procedure HandleFileChoice (theItem: INTEGER);		var			whichWindow: WindowPtr;	begin		case theItem of			NEW_ITEM: 				CreateWindow;			CLOSE_ITEM: 				begin					whichWindow := FrontWindow;					if whichWindow <> nil then						if IsDialogWindow(WindowPtr(gTheEvent.message)) then							DisposeDialog(GetDialogFromWindow(whichWindow))						else							DisposeWindow(whichWindow);				end;			PAGE_SETUP_ITEM: 				PageSetup;			PRINT_ITEM: 				Print;			QUIT_ITEM: 				gDone := TRUE;		end;	end;{--------------->     HandleAppleChoice     <--}	procedure HandleAppleChoice (theItem: INTEGER);		var			accName: Str255;			accNumber, itemNumber: INTEGER;			aMenu: MenuHandle;	begin		case theItem of			ABOUT_ITEM: 				HandleAbout;			otherwise				begin					aMenu := GetMenuHandle(APPLE_MENU_ID);					GetMenuItemText(aMenu, theItem, accName);					accNumber := OpenDeskAcc(accName);				end;		end;	end;{--------------->     HandleMenuChoice     <--}	procedure HandleMenuChoice (menuChoice: LONGINT);		var			theMenu, theItem: INTEGER;	begin		if menuChoice <> 0 then			begin				theMenu := HiWord(menuChoice);				theItem := LoWord(menuChoice);				case theMenu of					APPLE_MENU_ID: 						HandleAppleChoice(theItem);					FILE_MENU_ID: 						HandleFileChoice(theItem);					EDIT_MENU_ID: 						HandleEditChoice(theItem);				end;				HiliteMenu(0);			end;	end;{--------------->     AdjustMenus     <--}	procedure AdjustMenus;		var			aMenu: MenuHandle;	begin		if FrontWindow = nil then			begin				aMenu := GetMenuHandle(FILE_MENU_ID);				DisableItem(aMenu, CLOSE_ITEM);				aMenu := GetMenuHandle(EDIT_MENU_ID);				DisableItem(aMenu, UNDO_ITEM);				DisableItem(aMenu, CUT_ITEM);				DisableItem(aMenu, COPY_ITEM);				DisableItem(aMenu, PASTE_ITEM);				DisableItem(aMenu, CLEAR_ITEM);				DisableItem(aMenu, COPY_RESULT_ITEM);			end		else			begin				aMenu := GetMenuHandle(FILE_MENU_ID);				EnableItem(aMenu, CLOSE_ITEM);				{$IF TARGET_API_MAc_CARBON}				DisableItem(aMenu, PAGE_SETUP_ITEM);				DisableItem(aMenu, PRINT_ITEM);				{$ENDIF}			end;		aMenu := GetMenuHandle(EDIT_MENU_ID);		if IsDaWindow(FrontWindow) then			begin				EnableItem(aMenu, UNDO_ITEM);				EnableItem(aMenu, CUT_ITEM);				EnableItem(aMenu, COPY_ITEM);				EnableItem(aMenu, PASTE_ITEM);				EnableItem(aMenu, CLEAR_ITEM);				DisableItem(aMenu, COPY_RESULT_ITEM);			end		else			begin				DisableItem(aMenu, UNDO_ITEM);				EnableItem(aMenu, CUT_ITEM);				EnableItem(aMenu, COPY_ITEM);				EnableItem(aMenu, PASTE_ITEM);				EnableItem(aMenu, CLEAR_ITEM);				EnableItem(aMenu, COPY_RESULT_ITEM);			end;	end;{--------------->     HandleInput     <--}	procedure HandleInput (whichWindow: WindowPtr);		var			subsString: Str255;			sizeL: LongInt;			iType, item, result: Integer;			iHandle, point_handle, comma_handle, text_handle: Handle;			iRect: Rect;			myErr: OSErr;			caseData: CaseRecordHnd;	begin		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		subsString := DEC_POINT;		GetDialogItem(GetDialogFromWindow(whichWindow), TSH_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, TSH_String);		TSH := StandardForm(TSH_String);		TSH := TSH * caseData^^.TSHUnitFactor;		TSH_String := StringOf(TSH : 1 : 2);		GetDialogItem(GetDialogFromWindow(whichWindow), FT4_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, FT4_String);		FT4 := StandardForm(FT4_String);		FT4 := FT4 * UFT4;		FT4 := FT4 * caseData^^.FT4UnitFactor;		FT4_String := StringOf(FT4 / UFT4 : 1 : 2);		GetDialogItem(GetDialogFromWindow(whichWindow), FT3_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, FT3_String);		FT3 := StandardForm(FT3_String);		FT3 := FT3 * UFT3;		FT3 := FT3 * caseData^^.FT3UnitFactor;		FT3_String := StringOf(FT3 / UFT3 : 1 : 2);		Calculate;		gMessageString := concat(gSignalString, kReturn, '   TSH: ', TSH_String, TSH_Unit, kReturn, '   FT4: ', FT4_String, FT4_Unit, kReturn, '   FT3: ', FT3_String, FT3_Unit);		gMessageString := concat(gMessageString, kReturn, gParameterString, kReturn, '   GT: ', GTs, kReturn, '   GD: ', GDs);		gMessageString := concat(gMessageString, kReturn, gRefExp, kReturn, gGTRef, kReturn, gGDRef);{SetWRefCon(whichWindow, longint(CaseData)); {entbehrlich?}		caseData^^.TSH := TSH;		caseData^^.FT4 := FT4;		caseData^^.FT3 := FT3;		caseData^^.GT := GT;		caseData^^.GD := GD;		caseData^^.MessageString := gMessageString;		HUnlock(Handle(CaseData));		ShowMessage(whichWindow);	end;{----------------> DoContentClick <--}	procedure DoContentClick (whichWindow: WindowPtr);		var			oldPort: GrafPtr;			origSize, origFont, item: Integer;			theDialog: DialogPtr;			thePoint, popUpUpperLeft: Point;			theChoice: longint;			caseData: CaseRecordHnd;	begin		GetPort(oldPort);		SetPort(GetWindowPort(whichWindow));		thePoint := gTheEvent.where;		GlobalToLocal(thePoint);		origSize := GetPortTextSize(GetWindowPort(whichWindow));		origFont := GetPortTextFont(GetWindowPort(whichWindow));		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(NO_MEMORY);		HLock(Handle(CaseData));		if IsDialogEvent(gTheEvent) then			begin				if DialogSelect(gTheEvent, theDialog, item) then					if item = CALCULATE_BUTTON then						HandleInput(whichWindow);				if PtInRect(thePoint, gTSHPopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gTSHPopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gTSHPopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gTSHPopUpRect);						theChoice := PopUpMenuSelect(caseData^^.TSHPopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.TSHPopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.TSHPopUpItem := LoWord(theChoice);								caseData^^.TSHUnitFactor := 1;							end;						DrawPopUpItems(whichWindow);						FrameRect(gTSHPopUpRect);					end; {if PtInRect}				if PtInRect(thePoint, gFT4PopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gFT4PopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gFT4PopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gFT4PopUpRect);						theChoice := PopUpMenuSelect(caseData^^.FT4PopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.FT4PopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.FT4PopUpItem := LoWord(theChoice);								case caseData^^.FT4PopUpItem of									1: 										caseData^^.FT4UnitFactor := 1;									2: 										caseData^^.FT4UnitFactor := 0.1;									4: 										caseData^^.FT4UnitFactor := 1 / UFT4 / 1e12;								end;							end;						DrawPopUpItems(whichWindow);						FrameRect(gFT4PopUpRect);					end; {if PtInRect}				if PtInRect(thePoint, gFT3PopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gFT3PopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gFT3PopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gFT3PopUpRect);						theChoice := PopUpMenuSelect(caseData^^.FT3PopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.FT3PopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.FT3PopUpItem := LoWord(theChoice);								case caseData^^.FT3PopUpItem of									1, 2: 										caseData^^.FT3UnitFactor := 1;									4: 										caseData^^.FT3UnitFactor := 1 / UFT3 / 1e12;								end;							end;						DrawPopUpItems(whichWindow);						FrameRect(gFT3PopUpRect);					end; {if PtInRect}			end;		HUnLock(Handle(CaseData));		TextSize(origSize);		TextFont(origFont);		SetPort(oldPort);	end;{----------------> HandleMouseDown <--}	procedure HandleMouseDown;		var			whichWindow: WindowPtr;			thePart: INTEGER;			menuChoice, windSize: LONGINT;	begin		thePart := FindWindow(gTheEvent.where, whichWindow);		case thePart of			inMenuBar: 				begin					menuChoice := MenuSelect(gTheEvent.where);					HandleMenuChoice(menuChoice);				end;			inSysWindow: 				SystemClick(gTheEvent, whichWindow);			inDrag: 				DragWindow(whichWindow, gTheEvent.where, nil);			inGoAway: 				if TrackGoAway(whichWindow, gTheEvent.where) then					if IsDialogWindow(WindowPtr(gTheEvent.message)) then						DisposeDialog(GetDialogFromWindow(whichWindow))					else						DisposeWindow(whichWindow);			inContent: 				if whichWindow <> FrontWindow then					SelectWindow(whichWindow)				else					DoContentClick(whichWindow);		end;	end;{----------------> HandleKeyDown <--}	procedure HandleKeyDown;		var			key: Char;			iType, item: Integer;			iHandle: Handle;			iRect: Rect;			finalTicks: UInt32;			handled: Boolean;			theDialog: DialogPtr;	begin		handled := FALSE;		theDialog := GetDialogFromWindow(FrontWindow);		key := Char(BAnd(gTheEvent.message, charCodeMask));		if (key = char(kRETURN)) or (key = char(kENTER)) then			begin				if theDialog <> nil then					begin						if GetWRefCon(GetDialogWindow(theDialog))<>0 then						begin							SetPort(GetWindowPort(WindowPtr(theDialog)));							GetDialogItem(theDialog, CALCULATE_BUTTON, iType, iHandle, iRect);							HiliteControl(ControlHandle(iHandle), inButton);							Delay(kVISUAL, finalTicks);							HiliteControl(ControlHandle(iHandle), 0);							HandleInput(GetDialogWindow(theDialog));						end;						handled := TRUE;					end				else					begin						item := NoteAlert(RES_BASE + 10, nil);						handled := true;					end;			end;		if (BitAnd(gTheEvent.modifiers, cmdKey) <> 0) then			begin				AdjustMenus;				HandleMenuChoice(MenuKey(key));				handled := TRUE;			end;		if not handled then			if theDialog <> nil then				begin					if validkey(key) then						handled := DialogSelect(gTheEvent, theDialog, item);				end			else				item := NoteAlert(RES_BASE + 10, nil);	end;{----------------> HandleEvent <--}	procedure HandleEvent;		var			theChar: CHAR;			gotEvent, result: BOOLEAN;			oldPort: GrafPtr;			window: WindowPtr;			iHit, state: Integer;			control: ControlHandle;			iType, item: integer;			iHandle: Handle;			iRect: Rect;			theErr:OSErr;			theRgn:RgnHandle;			becomingActive: boolean;			theWindow:WindowPtr;	begin		if gWNEImplemented then			gotEvent := WaitNextEvent(everyEvent, gTheEvent, MIN_SLEEP, nil)		else			begin				SystemTask;				gotEvent := GetNextEvent(everyEvent, gTheEvent);			end;		if gotEvent then			case gTheEvent.what of			    kHighLevelEvent:				begin				theErr:=AEProcessAppleEvent(gTheEvent);				end;				mouseDown: 					begin						AdjustMenus;						HandleMouseDown;					end;				keyDown, autoKey: 					begin						if DialogPtr(gTheEvent.message)=gAboutDialog then SysBeep(30) else						HandleKeyDown;					end;				activateEvt: 					begin						state := BAnd(gTheEvent.modifiers, activeFlag);						if state = activeFlag then							becomingActive := true						else							becomingActive := false;						if (IsDialogWindow(WindowPtr(gTheEvent.message))) and (WindowPtr(gTheEvent.message) <> WindowPtr(gAboutDialog)) then							begin								{$IF TARGET_API_MAC_CARBON}								theErr:=GetRootControl(WindowPtr(gTheEvent.message),control);								if becomingActive then									theErr:=ActivateControl(control)								else									theErr:=DeActivateControl(control);								{$ELSE}								control := controlHandle(WindowPeek(WindowPtr(gTheEvent.message))^.controlList);								while control <> nil do									begin										HiliteControl(control, state + 255 mod 256);										control := control^^.nextControl;										GetDialogItem(WindowPtr(gTheEvent.message), CALCULATE_BUTTON, iType, iHandle, iRect);										DoOutlineControl(iHandle, CALCULATE_BUTTON);										result := DialogSelect(gTheEvent, WindowPtr(gTheEvent.message), item);									end;								{$ENDIF}							end;					end;				updateEvt: 					if not IsDAWindow(WindowPtr(gTheEvent.message)) then						begin							theWindow:=WindowPtr(gTheEvent.message);							AdjustMenus;							GetPort(oldPort);							SetPort(GetWindowPort(theWindow));							BeginUpdate(theWindow);							theRgn:=NewRgn;							theRgn:=GetPortVisibleRegion(GetWindowPort(theWindow), theRgn);							UpdateDialog(GetDialogFromWindow(theWindow), theRgn);							DisposeRgn(theRgn);							EndUpdate(theWindow);							if GetWRefCon(GetDialogWindow(DialogPtr(gTheEvent.message)))<>0 then							begin								GetDialogItem(GetDialogFromWindow(theWindow), CALCULATE_BUTTON, iType, iHandle, iRect);								DoOutlineControl(iHandle, CALCULATE_BUTTON);								DrawPopUps(theWindow);								ShowMessage(theWindow);							end;							SetPort(oldPort);						end;				nullEvent: 					begin						window := FrontWindow;						if IsDialogWindow(FrontWindow) then							result := DialogSelect(gTheEvent, GetDialogFromWindow(window), item);					end;			end		else			begin				window := FrontWindow;				if IsDialogWindow(FrontWindow) then					result := DialogSelect(gTheEvent, GetDialogFromWindow(window), item);			end;	end;{----------------> MainLoop <--}	procedure MainLoop;	begin		gDone := FALSE;		{$IF TARGET_API_MAC_CARBON}		gWNEImplemented:=true;		{$ELSE}		gWNEImplemented := (NGetTrapAddress(WNE_TRAP_NUM, ToolTrap) <> NGetTrapAddress(UNIMPL_TRAP_NUM, ToolTrap));		{$ENDIF}		while (gDone = FALSE) do			HandleEvent;		{$IF NOT TARGET_API_MAc_CARBON}		PrClose;		{$ENDIF}	end;{----------------> MenuBarInit <--}	procedure MenuBarInit;		var			myMenuBar: Handle;			aMenu,theMenu: MenuHandle;			response:longint;	begin		myMenuBar := GetNewMBar(RES_BASE);		if myMenuBar = nil then			ErrorHandler(NO_MBAR);		SetMenuBar(myMenuBar);		aMenu := GetMenuHandle(APPLE_MENU_ID);		if aMenu = nil then			ErrorHandler(NO_MENU);		{$IF NOT TARGET_API_MAc_CARBON}		  AddResMenu(aMenu, 'DRVR');		{$ENDIF}		aMenu := GetMenu(EDIT_MENU_ID);		if aMenu = nil then			ErrorHandler(NO_MENU);		aMenu := GetMenu(FILE_MENU_ID);		if aMenu = nil then			ErrorHandler(NO_MENU);					if (Gestalt(gestaltSystemVersion,response)=noErr) and (response>=$1000) then		begin			theMenu:=GetMenuHandle(FILE_MENU_ID);			if theMenu<>nil then			begin				DeleteMenuItem(theMenu,QUIT_ITEM);				DeleteMenuItem(theMenu,QUIT_ITEM-1);			end			else				ErrorHandler(NO_MENU);		end;				DrawMenuBar;	end;	{----------------> InitEvents <--}	procedure InitEvents;	var	  theErr: OSErr;		  response:longint;	begin	  	gDoOpenAppEventUPP := NewAEEventHandlerProc(AEEventHandlerProcPtr(@HandleOpenApplicationEvent));		gDoQuitAppEventUPP := NewAEEventHandlerProc(AEEventHandlerProcPtr(@DoQuitEvent));		if (Gestalt(gestaltSystemVersion,response)=noErr) and (response>=$0700) then  		begin  		 theErr:=AEInstallEventHandler(kCoreEventClass,kAEQuitApplication, gDoQuitAppEventUPP,0,false);  		 if theErr=noErr then   		  theErr:=AEInstallEventHandler(kCoreEventClass,kAEOpenApplication, gDoOpenAppEventUPP,0,false);  		 if theErr<>noErr then SysBeep(30);  		 FlushEvents(everyEvent, 0);  		end;	end;{----------------> SPINA-Thyr <--}begin	{$IF NOT TARGET_API_MAc_CARBON}	MaxApplZone;	{$ENDIF}	MoreMasters;	{$IF NOT TARGET_API_MAc_CARBON}	InitGraf(@qd.thePort);	InitFonts;	InitWindows;	InitMenus;	TEInit;	InitDialogs(nil);	{$ENDIF}	InitCursor;	MenuBarInit;	InitEvents;	ShowSplash;	{$IF NOT TARGET_API_MAc_CARBON}	PrintInit;	{$ENDIF}	gNewWindowLeft := WINDOW_HOME_LEFT;	gNewWindowTop := WINDOW_HOME_TOP;	gcalcCounter := 0;	SetRect(gMessageRect, 8, 110, 150, 240);	GetIndString(gnotcalculatableString, RES_BASE, 1);	GetIndString(gExplanationString, RES_BASE, 2);	GetIndString(gRefExp, RES_BASE, 3);	GetIndString(gGTRef, RES_BASE, 4);	GetIndString(gGDRef, RES_BASE, 5);	GetIndString(gSignalString, RES_BASE, 6);	GetIndString(gParameterString, RES_BASE, 7);	GetIndString(gPatName, RES_BASE + 1, 1);	GetIndString(gPatBirthday, RES_BASE + 1, 2);	GetIndString(gPatSender, RES_BASE + 1, 3);	GetIndString(gPrintingDate, RES_BASE + 1, 4);	GetIndString(gChooserName, RES_BASE + 1, 5);	GetIndString(gExaminationDate, RES_BASE + 1, 6);	HideWindow(GetDialogWindow(gSplashDialog));	CreateWindow;	MainLoop;end.