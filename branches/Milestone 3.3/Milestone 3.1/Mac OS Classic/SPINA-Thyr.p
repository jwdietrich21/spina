{ SPINA-Thyr }{ Programm zur Berechnung }{ von Strukturparametern }{ des thyreotropen }{ Regelkreises }{ Version 3.0 }{ J. W. Dietrich, Klinikum Innenstadt der LMU München 1997-2001}{ J. W. Dietrich, Universitätsklinikum Ulm 2002-2004}program SPINAThyr;	uses		Controls, Dialogs, Fonts, Lists, TextEdit, Menus, Packages, Processes, Memory, Strings, Resources, QuickDraw, SegLoad, Scrap, Sound, Devices, ToolUtils, OSUtils, Windows, Script, Printing, GestaltEqu, Folders;	const		GERMAN_RES_BASE = 400;		ENGLISH_RES_BASE = 800;		GER_APPLE_MENU_ID = 400;		GER_FILE_MENU_ID = 401;		GER_EDIT_MENU_ID = 402;		EN_APPLE_MENU_ID = 800;		EN_FILE_MENU_ID = 801;		EN_EDIT_MENU_ID = 802;		TSH_POPUP_MENU_ID = 410;		FT4_POPUP_MENU_ID = 411;		FT3_POPUP_MENU_ID = 412;		TT4_POPUP_MENU_ID = 611;		TT3_POPUP_MENU_ID = 612;		T4_METHOD_POPUP_MENU_ID = 413;		T3_METHOD_POPUP_MENU_ID = 414;		NOT_A_NORMAL_MENU = -1;		ABOUT_ITEM = 1;		NEW_ITEM = 1;		CLOSE_ITEM = 2;		PAGE_SETUP_ITEM = 4;		PRINT_ITEM = 5;		QUIT_ITEM = 7;		UNDO_ITEM = 1;		CUT_ITEM = 3;		COPY_ITEM = 4;		PASTE_ITEM = 5;		CLEAR_ITEM = 6;		COPY_RESULT_ITEM = 8;		POPUP_LEFT = 120;		POPUP_TOP = 190;		POPUP_RIGHT = 180;		POPUP_BOTTOM = 207;		SHADOW_PIXELS = 1;		RIGHT_MARGIN = 20;		BOTTOM_MARGIN = 4;		LEFT_MARGIN = 5;		PIXEL_FOR_TOP_LINE = 1;		POPUP_SIZE = 9;		ABOUT_OK_BUTTON = 1;		CALCULATE_BUTTON = 1;		RESULT_OK_BUTTON = 1;		RESULT_CAPTION = 2;		EDGE_THRESHOLD = 30;		WINDOW_HOME_LEFT = 40;		WINDOW_HOME_TOP = 45;		NEW_WINDOW_OFFSET = 20;		ACTIVATING = 1;		CONTROL_ACTIVATE = 0;		CONTROL_DEACTIVATE = $FF;		ON = 1;		OFF = 0;		MIN_SLEEP = 60;		LEAVE_WHERE_IT_IS = FALSE;		WNE_TRAP_NUM = $60;		UNIMPL_TRAP_NUM = $9F;		PAGE_MARGIN = 35;		NIL_STRING = '';		HOPELESSLY_FATAL_ERROR = 'Der Ressourcenzweig ist beschädigt.';		kENTER = char(3);		kTAB = char(9);		kRETURN = char(13);		kESCAPE = char(27);		kPERIOD = '.';		kVisual = 8;		inButton = 10;		inCheckBox = 11;		inUpButton = 20;		inDownButton = 21;		inThumb = 129;		rTypePrefs = 'PrFn';		kPrefsID = 401;		rTypeAppMiss = 'STR ';		kAppMissID = -16397;		DEC_POINT = '.';		DEC_COMMA = ',';		TEXT_WIDTH = 10;		TSH_Text = 2;		FT4_Text = 3;		FT3_Text = 4;		TSH_Unit_Item = 7;		FT4_Unit_Item = 9;		FT3_Unit_Item = 8;		T4_Method_Item = 10;		T3_Method_Item = 11;		UFT4 = 1.28e-11;		UFT3 = 1.54e-12;		ALPHAT = 0.1;		BETAT = 1.1e-6;		THY = 1;		I = 1;		DT = 2.75;		KT = 1;		KI = 1;		TBG = 3e-7;		TBPA = 4.5e-6;		K30 = 2e9;		K41 = 2e10;		K42 = 2e8;		ALPHA31 = 0.026;		BETA31 = 8e-6;		KM1 = 5e-7;	type		tMethod = (free, total);		tCodeList = set of 0..255;		CaseRecord = record				TSH, T4, T3, GT, GD: real;				TSHUnitFactor, FT4UnitFactor, FT3UnitFactor: real;				T4Method, T3Method: tMethod;				MethodsChanged: boolean;				WindowofChange: WindowPtr;				TSHPopUpItem, FT4PopUpItem, FT3PopUpItem: integer;				T4MethodPopUpItem, T3MethodPopUpItem: integer;				TSHPopUpMenu, FT4PopUpMenu, FT3PopUpMenu: MenuHandle;				T4MethodPopUpMenu, T3MethodPopUpMenu: MenuHandle;				MessageString, SheetString1, SheetString2, MessageLabel: Str255;			end;		CaseRecordPtr = ^CaseRecord;		CaseRecordHnd = ^CaseRecordPtr;		tPreferences = record				T4Method, T3Method: tMethod;				TSHUnitFactor, FT4UnitFactor, FT3UnitFactor: real;				TSHPopUpItem, FT4PopUpItem, FT3PopUpItem: integer;				T4MethodPopUpItem, T3MethodPopUpItem: integer;			end;		PrefsPointer = ^tPreferences;		PrefsHandle = ^PrefsPointer;	var		gResourceBase: integer;		gNoMBAR, gNoMENU, gNoPICTURE, gNoWIND, gNoTEXT, gNoMEMORY: integer;		gErrorAlertID, gAboutAlert: integer;		TSH, T4, T3, GT, GD: real;		gDone, gWNEImplemented: Boolean;		gTheEvent: EventRecord;		gNewWindowLeft, gNewWindowTop: integer;		gTSHPopUpRect, gFT4PopUpRect, gFT3PopUpRect: Rect;		gT4MethodPopUpRect, gT3MethodPopUpRect: Rect;		gAboutDialog, gSplashDialog: DialogPtr;		gCalcButton: ControlHandle;		gMessageRect: Rect;		gcalcTitle, gStandardCalcTitle, gcalcString, gnotcalculatableString, GTs, GDs: Str255;		gExplanationString, gMessageString, gSheetMessage, TSH_String, FT4_String, FT3_String: Str255;		gRefExp, gGTRef, gGDRef, gSignalString, gParameterString: Str255;		TSH_Unit, FT4_Unit, FT3_Unit: Str255;		gPatName, gPatBirthday, gPatSender, gChooserName, gPrintingDate, gExaminationDate: Str255;		gHintString, gResultString: Str255;		gcalcCounter: longint;		gPrintRecordH: THPrint;		gfinalTicks: UInt32;		gDoOpenAppEventUPP: AEEventHandlerUPP;		gDoReopenAppEventUPP: AEEventHandlerUPP;		gDoOpenDocsEventUPP: AEEventHandlerUPP;		gDoPrintDocsEventUPP: AEEventHandlerUPP;		gDoQuitAppEventUPP: AEEventHandlerUPP;		gPreferences: tPreferences;		gAppResFileRefNum, gPrefsFileRefNum: integer;		gItl0Handle: Intl0Hndl;		gRegion: integer;		gGermanCodes: tCodeList;{----------------> ErrorHandler <--}	procedure ErrorHandler (stringNum: INTEGER);		var			errorStringH: StringHandle;			result: INTEGER;	begin		errorStringH := GetString(stringNum);		if errorStringH = nil then			ParamText(HOPELESSLY_FATAL_ERROR, NIL_STRING, NIL_STRING, NIL_STRING)		else			ParamText(errorStringH^^, NIL_STRING, NIL_STRING, NIL_STRING);		result := StopAlert(gErrorAlertID, nil);		ExitToShell;	end;{--------------->     IsDAWindow     <--}	function IsDAWindow (whichWindow: WindowPtr): BOOLEAN;	begin		if whichWindow = nil then			isDaWindow := FALSE		else			IsDaWindow := (WindowPeek(whichWindow)^.windowKind < 0);	end;{--------------->     IsDialogWindow     <--}	function IsDialogWindow (theWindow: WindowPtr): Boolean;	begin		if theWindow = nil then			IsDialogWindow := FALSE		else			IsDialogWindow := WindowPeek(theWindow)^.windowKind = dialogKind;	end;{----------------> CopyResource <--}	function CopyResource (theResType: ResType; resID, sourceFileRefNum, destFileRefNum: integer): OSErr;		var			oldResFileRefNum: integer;			sourceResourceHdl: Handle;			ignoredType: ResType;			ignoredID: integer;			resourceName: Str255;			resAttributes: integer;			theError: OSErr;	begin		oldResFileRefNum := CurResFile;		UseResFile(sourceFileRefNum);		sourceResourceHdl := Get1Resource(theResType, resID);		if (sourceResourceHdl <> nil) then			begin				GetResInfo(sourceResourceHdl, ignoredID, ignoredType, resourceName);				resAttributes := GetResAttrs(sourceResourceHdl);				DetachResource(sourceResourceHdl);				UseResFile(destFileRefNum);				if (ResError = noErr) then					AddResource(sourceResourceHdl, theResType, resID, resourceName);				if (ResError = noErr) then					SetResAttrs(sourceResourceHdl, resAttributes);				if (ResError = noErr) then					ChangedResource(sourceResourceHdl);				if (ResError = noErr) then					WriteResource(sourceResourceHdl);			end;		theError := ResError;		ReleaseResource(sourceResourceHdl);		UseResFile(oldResFileRefNum);		CopyResource := theError;	end;{----------------> BlankPreferences <--}	procedure BlankPreferences;	{Standardwerte für die Voreinstellungen}	begin		with gPreferences do			begin				T4Method := free;				T3Method := free;				TSHUnitFactor := 1;				FT4UnitFactor := 1;				FT3UnitFactor := 1;				TSHPopUpItem := 1;				FT4PopUpItem := 1;				FT3PopUpItem := 1;				T4MethodPopUpItem := 1;				T3MethodPopUpItem := 1;			end;	end;{----------------> SavePreferences <--}	procedure SavePreferences;		var			thePrefsHandle: PrefsHandle;			existingResHdl: Handle;			resourceName: Str255;	begin		resourceName := 'Preferences';		if (gPrefsFileRefNum = -1) then			begin				Exit(SavePreferences);			end;		thePrefsHandle := PrefsHandle(NewHandleClear(sizeof(tPreferences)));		HLock(Handle(thePrefsHandle));		with thePrefsHandle ^ ^ . do		begin			T4Method := gPreferences.T4Method;			T3Method := gPreferences.T3Method;			TSHUnitFactor := gPreferences.TSHUnitFactor;			FT4UnitFactor := gPreferences.FT4UnitFactor;			FT3UnitFactor := gPreferences.FT3UnitFactor;			TSHPopUpItem := gPreferences.TSHPopUpItem;			FT4PopUpItem := gPreferences.FT4PopUpItem;			FT3PopUpItem := gPreferences.FT3PopUpItem;			T4MethodPopUpItem := gPreferences.T4MethodPopUpItem;			T3MethodPopUpItem := gPreferences.T3MethodPopUpItem;		end;		UseResFile(gPrefsFileRefNum);		existingResHdl := Get1Resource(rTypePrefs, kPrefsID);		if (existingResHdl <> nil) then			RemoveResource(existingResHdl);		if (ResError = noErr) then			AddResource(Handle(thePrefsHandle), rTypePrefs, kPrefsID, resourceName);		if (ResError = noErr) then			WriteResource(Handle(thePrefsHandle));		HUnLock(Handle(thePrefsHandle));		ReleaseResource(Handle(thePrefsHandle));		UseResFile(gAppResFileRefNum);	end;{----------------> GetPreferences <--}	procedure GetPreferences;		var			theFileName: Str255;			theError: OSErr;			volRefNum: integer;			directoryID, response: longint;			fileSSpec: FSSpec;			fileRefNum: integer;			FindFolderPresent: boolean;			theEnv: SysEnvRec;			thePreferences: tPreferences;			thePrefsHandle: PrefsHandle;			existingResHdl: Handle;			resourceName: Str255;	begin		resourceName := 'Preferences';		theError := SysEnvirons(1, theEnv);		if theEnv.SystemVersion < $0604 then			FindFolderPresent := false		else			begin				theError := Gestalt('fold', response);				if (theError = noErr) then					FindFolderPresent := (response > 0)				else					FindFolderPresent := false;			end;		GetIndString(theFileName, gResourceBase + 2, 1);		if FindFolderPresent then			theError := FindFolder(kOnSystemDisk, kPreferencesFolderType, kDontCreateFolder, volRefNum, directoryID)		else			directoryID := theEnv.sysVRefNum;	{für Mac OS 6}		if theError = noErr then			theError := FSMakeFSSpec(volRefNum, directoryID, theFileName, fileSSpec);		if ((theError = noErr) or (theError = fnfErr)) then			fileRefNum := FSpOpenResFile(fileSSpec, fsCurPerm);		if (fileRefNum = -1) then {Datei noch nicht angelegt}			begin				FSpCreateResFile(fileSSpec, 'SPIt', 'pref', smSystemScript);				theError := ResError;				if (theError = noErr) then					begin						fileRefNum := FSpOpenResFile(fileSSpec, fsCurPerm);						if (fileRefNum <> -1) then							begin								UseResFile(gAppResFileRefNum);								theError := CopyResource(rTypePrefs, kPrefsID, gAppResFileRefNum, fileRefNum);								if (theError = noErr) then									theError := CopyResource(rTypeAppMiss, kAppMissID, gAppResFileRefNum, fileRefNum);								if theError = noErr then									begin										UseResFile(fileRefNum);										thePreferences := gPreferences;										thePrefsHandle := PrefsHandle(NewHandleClear(sizeof(tPreferences)));										HLock(Handle(thePrefsHandle));										with thePrefsHandle ^ ^ . do										begin											T4Method := gPreferences.T4Method;											T3Method := gPreferences.T3Method;											TSHUnitFactor := gPreferences.TSHUnitFactor;											FT4UnitFactor := gPreferences.FT4UnitFactor;											FT3UnitFactor := gPreferences.FT3UnitFactor;											TSHPopUpItem := gPreferences.TSHPopUpItem;											FT4PopUpItem := gPreferences.FT4PopUpItem;											FT3PopUpItem := gPreferences.FT3PopUpItem;											T4MethodPopUpItem := gPreferences.T4MethodPopUpItem;											T3MethodPopUpItem := gPreferences.T3MethodPopUpItem;										end;										existingResHdl := Get1Resource(rTypePrefs, kPrefsID);										if (existingResHdl <> nil) then											RemoveResource(existingResHdl);										if (ResError = noErr) then											AddResource(Handle(thePrefsHandle), rTypePrefs, kPrefsID, resourceName);										if (ResError = noErr) then											WriteResource(Handle(thePrefsHandle));										HUnLock(Handle(thePrefsHandle));										ReleaseResource(Handle(thePrefsHandle));									end;								if (theError <> noErr) then									begin										CloseResFile(fileRefNum);										theError := FSpDelete(fileSSpec);										fileRefNum := -1;									end;							end;					end;			end;		if (fileRefNum <> -1) then	{Datei existiert}			begin				UseResFile(fileRefNum);				thePrefsHandle := PrefsHandle(Get1Resource(rTypePrefs, kPrefsID));				if (thePrefsHandle = nil) then					Exit(GetPreferences);				with thePrefsHandle ^ ^ . do				begin					gPreferences.T4Method := T4Method;					gPreferences.T3Method := T3Method;					gPreferences.TSHUnitFactor := TSHUnitFactor;					gPreferences.FT4UnitFactor := FT4UnitFactor;					gPreferences.FT3UnitFactor := FT3UnitFactor;					gPreferences.TSHPopUpItem := TSHPopUpItem;					gPreferences.FT4PopUpItem := FT4PopUpItem;					gPreferences.FT3PopUpItem := FT3PopUpItem;					gPreferences.T4MethodPopUpItem := T4MethodPopUpItem;					gPreferences.T3MethodPopUpItem := T3MethodPopUpItem;				end;				gPrefsFileRefNum := fileRefNum;				UseResFile(gAppResFileRefNum);			end;	end;{----------------> PrintInit <--}	procedure PrintInit;	begin		PrOpen;		gPrintRecordH := THPrint(NewHandle(sizeof(TPrint)));		PrintDefault(gPrintRecordH);		prClose;	end;{----------------> PageSetup <--}	procedure PageSetup;		var			keepGoing: boolean;	begin		prOpen;		keepGoing := PrStlDialog(gPrintRecordH);		prClose;	end;{----------------> Print <--}	procedure Print;		var			keepGoing: boolean;			thePict: PicHandle;			theWindow: WindowPtr;			printPort: TPPrPort;			printStatus: TPPrStatusRef;			origFont, origSize: INTEGER;			oldPort: GrafPtr;			DrawingRect, tempRect: Rect;			caseData: CaseRecordHnd;			theString, chooserString, dateString: Str255;			currentTime: UInt32;	begin		theWindow := frontWindow;		if IsDialogWindow(theWindow) then			begin				prOpen;				keepGoing := PrJobDialog(gPrintRecordH);				if keepGoing then					begin						with DrawingRect do							begin								left := gPrintRecordH^^.prInfo.rPage.left + 3 * PAGE_MARGIN;								top := gPrintRecordH^^.prInfo.rPage.top + PAGE_MARGIN;								right := gPrintRecordH^^.prInfo.rPage.right - PAGE_MARGIN;								bottom := gPrintRecordH^^.prInfo.rPage.bottom - PAGE_MARGIN;							end;						tempRect := DrawingRect;						thePict := GetPicture(gResourceBase + 2);						if thePict = nil then							ErrorHandler(gNoPICTURE);						with thePict^^.picFrame do							begin								tempRect.right := tempRect.left + (right - left) div 2;								tempRect.bottom := tempRect.top + (bottom - top) div 2;							end;						GetPort(oldPort);						HLock(Handle(thePict));						printPort := TPPrPort(PrOpenDoc(gPrintRecordH, nil, nil));						if (OSErr(PrError) = noErr) then							PrOpenPage(pointer(printPort), nil);						if (OSErr(PrError) = noErr) then							begin								DrawPicture(thePict, tempRect);								MoveTo(tempRect.left, tempRect.bottom + 5);								LineTo(DrawingRect.right, tempRect.bottom + 5);								origFont := theWindow^.txFont;								origSize := theWindow^.txSize;								TextFont(applFont);								TextSize(10);								with tempRect do									begin										top := bottom + 30;										right := DrawingRect.right;										bottom := top + 3 * 10 * 2;									end;								theString := concat(gPatName, kReturn, gPatBirthday, kReturn, gPatSender, kReturn, gExaminationDate);								TETextBox(Pointer(ord(@theString) + 1), length(theString), tempRect, teFlushLeft);								with tempRect do									begin										top := bottom + 30;										right := DrawingRect.right;										bottom := top + gMessageRect.bottom - gMessageRect.top;									end;								caseData := CaseRecordHnd(GetWRefCon(theWindow));								if caseData = nil then									ErrorHandler(gNoMEMORY);								HLock(Handle(CaseData));								theString := caseData^^.MessageString;								HUnlock(Handle(CaseData));								TETextBox(Pointer(ord(@theString) + 1), length(theString), tempRect, teFlushLeft);								MoveTo(DrawingRect.left, DrawingRect.bottom - 20);								chooserString := Str255(GetString(-16096)^^);								GetDateTime(currentTime);								IUDateString(currentTime, 1, dateString);								theString := concat(gChooserName, chooserString, ' • ', gPrintingDate, dateString);								DrawString(theString);								TextFont(origFont);								TextSize(origSize);								PrClosePage(pointer(printPort));							end;						PrCloseDoc(pointer(printPort));						if ((gPrintRecordH^^.prJob.bJDocLoop = bSpoolLoop) and (PrError = noErr)) then							PrPicFile(gPrintRecordH, nil, nil, nil, printStatus);						HUnlock(Handle(thePict));						SetPort(oldPort);						prClose;					end;			end;	end;{----------------> AppleEvent-Handlers <--}	function GotRequiredParams (theAppleEvent: AppleEvent): OSErr;    (* standard AppleEvent routine copied out of NIM:IAC *)		var			typeCode: DescType;			actualSize: Size;			err: OSErr;	begin		err := noErr;		err := AEGetAttributePtr(theAppleEvent, keyMissedKeywordAttr, typeWildCard, typeCode, nil, 0, actualSize);		if err = errAEDescNotFound then			begin				GotRequiredParams := noErr;			end		else if err = noErr then			begin				GotRequiredParams := errAEEventNotHandled;			end		else			begin				GotRequiredParams := noErr;			end; (* if *)	end; (* GotRequiredParams *)	function DoQuitEvent (var theAppleEvent, reply: AppleEvent; refcon: longint): OSErr;		var			theErr: OSErr;	begin		theErr := GotRequiredParams(theAppleEvent);		gDone := true;		DoQuitEvent := noErr;	end;	function HandleOpenApplicationEvent (theAppleEvent, reply: AppleEvent; refcon: longint): OSErr;		var			theErr: OSErr;	begin		theErr := GotRequiredParams(theAppleEvent);		HandleOpenApplicationEvent := theErr;	end;{----------------> DrawPopUpItems <--}	procedure DrawPopUpItems (theWindow: WindowPtr);		var			menuItem: Str255;			origSize, origFont: integer;			ItemLeftMargin, arrowHeight, arrowWidth: integer;			caseData: CaseRecordHnd;			theArrow: PicHandle;			arrowRect: Rect;	begin		origSize := theWindow^.txSize;		origFont := theWindow^.txFont;		TextSize(POPUP_SIZE);		TextFont(applFont);		theArrow := GetPicture(gResourceBase + 10);		arrowHeight := theArrow^^.picFrame.bottom - theArrow^^.picFrame.top;		arrowWidth := theArrow^^.picFrame.right - theArrow^^.picFrame.left;		caseData := CaseRecordHnd(GetWRefCon(theWindow));		if caseData = nil then			ErrorHandler(gNoMEMORY);		HLock(Handle(CaseData));		GetMenuItemText(caseData^^.TSHPopUpMenu, caseData^^.TSHPopUpItem, menuItem);		ItemLeftMargin := (gTSHPopUpRect.right - gTSHPopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gTSHPopUpRect;		with arrowRect do			begin				top := gTSHPopUpRect.top + 6;				right := gTSHPopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gTSHPopUpRect.left + itemLeftMargin, gTSHPopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		GetMenuItemText(caseData^^.FT4PopUpMenu, caseData^^.FT4PopUpItem, menuItem);		ItemLeftMargin := (gFT4PopUpRect.right - gFT4PopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gFT4PopUpRect;		with arrowRect do			begin				top := gFT4PopUpRect.top + 6;				right := gFT4PopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gFT4PopUpRect.left + itemLeftMargin, gFT4PopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		GetMenuItemText(caseData^^.FT3PopUpMenu, caseData^^.FT3PopUpItem, menuItem);		ItemLeftMargin := (gFT3PopUpRect.right - gFT3PopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gFT3PopUpRect;		with arrowRect do			begin				top := gFT3PopUpRect.top + 6;				right := gFT3PopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gFT3PopUpRect.left + itemLeftMargin, gFT3PopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		GetMenuItemText(caseData^^.T4MethodPopUpMenu, caseData^^.T4MethodPopUpItem, menuItem);		ItemLeftMargin := (gT4MethodPopUpRect.right - gT4MethodPopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gT4MethodPopUpRect;		with arrowRect do			begin				top := gT4MethodPopUpRect.top + 6;				right := gT4MethodPopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gT4MethodPopUpRect.left + itemLeftMargin, gT4MethodPopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		GetMenuItemText(caseData^^.T3MethodPopUpMenu, caseData^^.T3MethodPopUpItem, menuItem);		ItemLeftMargin := (gT3MethodPopUpRect.right - gT3MethodPopUpRect.left - StringWidth(menuItem)) div 2;		ItemLeftMargin := 3;		arrowRect := gT3MethodPopUpRect;		with arrowRect do			begin				top := gT3MethodPopUpRect.top + 6;				right := gT3MethodPopUpRect.right - 3;				left := right - arrowWidth;				bottom := top + arrowHeight;			end;		DrawPicture(theArrow, arrowRect);		MoveTo(gT3MethodPopUpRect.left + itemLeftMargin, gT3MethodPopUpRect.bottom - BOTTOM_MARGIN);		DrawString(menuItem);		HUnlock(Handle(CaseData));		TextSize(origSize);		TextFont(origFont);	end;{----------------> DrawPopUps <--}	procedure DrawPopUps (theWindow: WindowPtr);		var			iType: integer;			iHandle: Handle;			iRect: Rect;	begin		GetDialogItem(theWindow, TSH_Unit_Item, iType, iHandle, iRect);		gTSHPopUpRect := iRect;		FrameRect(gTSHPopUpRect);		with gTSHPopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		GetDialogItem(theWindow, FT4_Unit_Item, iType, iHandle, iRect);		gFT4PopUpRect := iRect;		EraseRect(gFT4PopUpRect);		FrameRect(gFT4PopUpRect);		with gFT4PopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		GetDialogItem(theWindow, FT3_Unit_Item, iType, iHandle, iRect);		gFT3PopUpRect := iRect;		EraseRect(gFT3PopUpRect);		FrameRect(gFT3PopUpRect);		with gFT3PopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		GetDialogItem(theWindow, T4_Method_Item, iType, iHandle, iRect);		gT4MethodPopUpRect := iRect;		FrameRect(gT4MethodPopUpRect);		with gT4MethodPopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		GetDialogItem(theWindow, T3_Method_Item, iType, iHandle, iRect);		gT3MethodPopUpRect := iRect;		FrameRect(gT3MethodPopUpRect);		with gT3MethodPopUpRect do			begin				MoveTo(left + SHADOW_PIXELS, bottom);				LineTo(right, bottom);				LineTo(right, top + SHADOW_PIXELS);			end;		DrawPopUpItems(theWindow);	end;{----------------> PopUpMenuInit <--}	procedure PopUpMenuInit (whichWindow: WindowPtr);		var			caseData: CaseRecordHnd;			i: integer;			theString: Str255;	begin		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(gNoMEMORY);		HLock(Handle(CaseData));		with caseData^^ do			begin				TSHPopUpMenu := GetMenu(TSH_POPUP_MENU_ID);				InsertMenu(TSHPopUpMenu, NOT_A_NORMAL_MENU);				if T4Method = free then					FT4PopUpMenu := GetMenu(FT4_POPUP_MENU_ID)				else					FT4PopUpMenu := GetMenu(TT4_POPUP_MENU_ID);				InsertMenu(FT4PopUpMenu, NOT_A_NORMAL_MENU);				if T3Method = free then					FT3PopUpMenu := GetMenu(FT3_POPUP_MENU_ID)				else					FT3PopUpMenu := GetMenu(TT3_POPUP_MENU_ID);				InsertMenu(FT3PopUpMenu, NOT_A_NORMAL_MENU);				T4MethodPopUpMenu := GetMenu(T4_METHOD_POPUP_MENU_ID);				InsertMenu(T4MethodPopUpMenu, NOT_A_NORMAL_MENU);				T3MethodPopUpMenu := GetMenu(T3_METHOD_POPUP_MENU_ID);				InsertMenu(T3MethodPopUpMenu, NOT_A_NORMAL_MENU);				MethodsChanged := false;			end;	end;{--------------->     ShowMessage     <--}	procedure ShowMessage (theWindow: WindowPtr);		var			origFont, origSize: INTEGER;			theString, theLabel: Str255;			caseData: CaseRecordHnd;			oldPort: GrafPtr;			theRect, labelRect: Rect;	begin		if theWindow <> nil then			begin				GetPort(oldPort);				SetPort(theWindow);				caseData := CaseRecordHnd(GetWRefCon(theWindow));				if caseData = nil then					ErrorHandler(gNoMEMORY);				HLock(Handle(CaseData));				theString := caseData^^.MessageString;				theLabel := caseData^^.MessageLabel;				HUnlock(Handle(CaseData));				origFont := theWindow^.txFont;				origSize := theWindow^.txSize;				TextFont(applFont);				TextSize(10);				TETextBox(Pointer(ord(@theString) + 1), length(theString), gMessageRect, teFlushLeft);				theRect := gMessageRect;				InsetRect(theRect, -3, -7);				FrameRect(theRect);				SetRect(labelRect, theRect.left + 5, theRect.top - 5, theRect.left + StringWidth(theLabel) + 5, theRect.top + 5);				EraseRect(labelRect);				MoveTo(theRect.left + 7, theRect.top + 3);				DrawString(theLabel);				TextFont(origFont);				TextSize(origSize);				SetPort(oldPort);			end;	end;{--------------->     DoOutlineControl     <--}	procedure DoOutlineControl (theControl: univ ControlHandle);		var			theOval: INTEGER;			theRect: Rect;			origPen: PenState;			oldPort: GrafPtr;	begin		if theControl <> nil then			begin				GetPort(oldPort);				SetPort(theControl^^.contrlOwner);				GetPenState(origPen);				PenNormal;				theRect := theControl^^.contrlRect;				InsetRect(theRect, -4, -4);				theOval := ((theRect.bottom - theRect.top) div 2) + 2;				if (theControl^^.contrlHilite = CONTROL_ACTIVATE) then					PenPat(qd.black)				else					PenPat(qd.gray);				PenSize(3, 3);				FrameRoundRect(theRect, theOval, theOval);				SetPenState(origPen);				SetPort(oldPort);			end;	end;{--------------->      Calculate     <--}	procedure Calculate (theT4Method, theT3Method: tMethod);	begin		if TSH > 0 then			begin				case theT4Method of					free: 						GT := betaT * (DT + TSH) * (1 + k41 * TBG + k42 * TBPA) * T4 / (alphaT * TSH);					total: 						GT := betaT * (DT + TSH) * T4 / (alphaT * TSH);				end;				GTs := concat(StringOf(1e12 * GT : 5 : 2), ' pmol/s');			end		else			GTs := gnotcalculatableString;		if T4 > 0 then			begin				case theT4Method of					free: 						begin							case theT3Method of								free: 									GD := beta31 * (kM1 + T4) * (1 + k30 * TBG) * T3 / (alpha31 * T4);								total: 									GD := beta31 * (kM1 + T4) * T3 / (alpha31 * T4);							end;						end;					total: 						begin							T4 := T4 / (1 + k41 * TBG + k42 * TBPA);							case theT3Method of								free: 									GD := beta31 * (kM1 + T4) * (1 + k30 * TBG) * T3 / (alpha31 * T4);								total: 									GD := beta31 * (kM1 + T4) * T3 / (alpha31 * T4);							end;						end;				end;				GDs := concat(StringOf(1e9 * GD : 5 : 2), ' nmol/s');			end		else			GDs := gnotcalculatableString;	end;{--------------->      CenterPict     <--}	procedure CenterPict (thePicture: PicHandle; var myRect: Rect);		var			windRect, pictureRect: Rect;	begin		WindRect := myRect;		pictureRect := thePicture^^.picFrame;		myRect.top := (windRect.bottom - windRect.top - (pictureRect.bottom - pictureRect.top)) div 2 + windRect.top;		myRect.bottom := myRect.top + (pictureRect.bottom - pictureRect.top);		myRect.left := (windRect.right - windRect.left - (pictureRect.right - pictureRect.left)) div 2 + windRect.left;		myRect.right := myRect.left + (pictureRect.right - pictureRect.left);	end;{--------------->     DrawPictures     <--}	procedure DrawPictures (pictureWindow: WindowPtr);		var			myRect: Rect;			thePicture: picHandle;	begin		myRect := pictureWindow^.portRect;		thePicture := GetPicture(gResourceBase + 1);		if thePicture = nil then			ErrorHandler(gNoPICTURE);		SetRect(myRect, 126, 19, 371, 236);		SetPort(pictureWindow);		DrawPicture(thePicture, myRect);		thePicture := GetPicture(gResourceBase + 2);		if thePicture = nil then			ErrorHandler(gNoPICTURE);		SetRect(myRect, 8, 39, 135, 104);		SetPort(pictureWindow);		DrawPicture(thePicture, myRect);	end;{--------------->     AdjustMenus     <--}	procedure AdjustMenus;		var			aMenu: MenuHandle;			caseData: CaseRecordHnd;			oldPort: GrafPtr;			theWindow: WindowPtr;	begin		theWindow := FrontWindow;		if theWindow = nil then			begin				if gResourceBase = GERMAN_RES_BASE then					aMenu := GetMenuHandle(GER_FILE_MENU_ID)				else					aMenu := GetMenuHandle(EN_FILE_MENU_ID);				DisableItem(aMenu, CLOSE_ITEM);				if gResourceBase = GERMAN_RES_BASE then					aMenu := GetMenuHandle(GER_EDIT_MENU_ID)				else					aMenu := GetMenuHandle(EN_EDIT_MENU_ID);				DisableItem(aMenu, UNDO_ITEM);				DisableItem(aMenu, CUT_ITEM);				DisableItem(aMenu, COPY_ITEM);				DisableItem(aMenu, PASTE_ITEM);				DisableItem(aMenu, CLEAR_ITEM);				DisableItem(aMenu, COPY_RESULT_ITEM);			end		else if IsDialogWindow(theWindow) then			begin				if gResourceBase = GERMAN_RES_BASE then					aMenu := GetMenuHandle(GER_FILE_MENU_ID)				else					aMenu := GetMenuHandle(EN_FILE_MENU_ID);				EnableItem(aMenu, CLOSE_ITEM);				caseData := CaseRecordHnd(GetWRefCon(theWindow));				if caseData = nil then					ErrorHandler(gNoMEMORY);				HLock(Handle(CaseData));				if (caseData^^.MethodsChanged) and (theWindow = caseData^^.WindowofChange) then					begin						GetPort(oldPort);						SetPort(theWindow);						DisposeMenu(caseData^^.FT4PopUpMenu);						case caseData^^.T4Method of							free: 								caseData^^.FT4PopUpMenu := GetMenu(FT4_POPUP_MENU_ID);							total: 								caseData^^.FT4PopUpMenu := GetMenu(TT4_POPUP_MENU_ID);						end;						DisposeMenu(caseData^^.FT3PopUpMenu);						case caseData^^.T3Method of							free: 								caseData^^.FT3PopUpMenu := GetMenu(FT3_POPUP_MENU_ID);							total: 								caseData^^.FT3PopUpMenu := GetMenu(TT3_POPUP_MENU_ID);						end;						DrawPopUps(theWindow);						SetPort(oldPort);						caseData^^.MethodsChanged := false;					end;				with gPreferences do					begin						T4Method := caseData^^.T4Method;						T3Method := caseData^^.T3Method;						TSHUnitFactor := caseData^^.TSHUnitFactor;						FT4UnitFactor := caseData^^.FT4UnitFactor;						FT3UnitFactor := caseData^^.FT3UnitFactor;						TSHPopUpItem := caseData^^.TSHPopUpItem;						FT4PopUpItem := caseData^^.FT4PopUpItem;						FT3PopUpItem := caseData^^.FT3PopUpItem;						T4MethodPopUpItem := caseData^^.T4MethodPopUpItem;						T3MethodPopUpItem := caseData^^.T3MethodPopUpItem;					end;				HUnlock(Handle(CaseData));			end;		if gResourceBase = GERMAN_RES_BASE then			aMenu := GetMenuHandle(GER_EDIT_MENU_ID)		else			aMenu := GetMenuHandle(EN_EDIT_MENU_ID);		if IsDaWindow(theWindow) then			begin				EnableItem(aMenu, UNDO_ITEM);				EnableItem(aMenu, CUT_ITEM);				EnableItem(aMenu, COPY_ITEM);				EnableItem(aMenu, PASTE_ITEM);				EnableItem(aMenu, CLEAR_ITEM);				DisableItem(aMenu, COPY_RESULT_ITEM);			end		else			begin				DisableItem(aMenu, UNDO_ITEM);				EnableItem(aMenu, CUT_ITEM);				EnableItem(aMenu, COPY_ITEM);				EnableItem(aMenu, PASTE_ITEM);				EnableItem(aMenu, CLEAR_ITEM);				EnableItem(aMenu, COPY_RESULT_ITEM);			end;	end;{--------------->     CreateWindow     <--}	procedure CreateWindow;		var			theNewestWindow: DialogPtr;			oldPort: GrafPtr;			iType: integer;			iHandle: Handle;			iRect: Rect;			caseData: CaseRecordHnd;	begin		theNewestWindow := GetNewDialog(gResourceBase + 1, nil, WindowPtr(-1));		if theNewestWindow = nil then			ErrorHandler(gNoWIND);		if ((qd.screenBits.bounds.right - gNewWindowLeft) < EDGE_THRESHOLD) or ((qd.screenBits.bounds.bottom - gNewWindowTop) < EDGE_THRESHOLD) then			begin				gNewWindowLeft := WINDOW_HOME_LEFT;				gNewWindowTop := WINDOW_HOME_TOP;			end;		gCalcTitle := gStandardCalcTitle;		gcalcCounter := gcalcCounter + 1;		if gcalcCounter > 1 then			begin				NumToString(gcalcCounter, gcalcString);				gcalcTitle := concat(gcalcTitle, ' ', gcalcString);			end;		SetWTitle(theNewestWindow, gcalcTitle);		gMessageString := gExplanationString;		caseData := CaseRecordHnd(NewHandle(sizeof(CaseRecord)));		if caseData = nil then			ErrorHandler(gNoMEMORY);		HLock(Handle(CaseData));		SetWRefCon(theNewestWindow, longint(CaseData));		with caseData^^ do			begin				TSH := TSH;				T4 := T4;				T3 := T3;				GT := GT;				GD := GD;				MessageString := gMessageString;				SheetString1 := gSheetMessage;				SheetString2 := '';				MessageLabel := gHintString;				T4Method := gPreferences.T4Method;				T3Method := gPreferences.T3Method;				TSHUnitFactor := gPreferences.TSHUnitFactor;				FT4UnitFactor := gPreferences.FT4UnitFactor;				FT3UnitFactor := gPreferences.FT3UnitFactor;				TSHPopUpItem := gPreferences.TSHPopUpItem;				FT4PopUpItem := gPreferences.FT4PopUpItem;				FT3PopUpItem := gPreferences.FT3PopUpItem;				T4MethodPopUpItem := gPreferences.T4MethodPopUpItem;				T3MethodPopUpItem := gPreferences.T3MethodPopUpItem;			end;		HUnlock(Handle(CaseData));		MoveWindow(theNewestWindow, gNewWindowLeft, gNewWindowTop, LEAVE_WHERE_IT_IS);		gNewWindowLeft := gNewWindowLeft + NEW_WINDOW_OFFSET;		gNewWindowTop := gNewWindowTop + NEW_WINDOW_OFFSET;		GetDialogItem(theNewestWindow, TSH_Text, iType, iHandle, iRect);		SetDialogItemText(iHandle, '0');		SelectDialogItemText(theNewestWindow, TSH_Text, 0, 32767);		GetPort(oldPort);		SetPort(theNewestWindow);		ShowWindow(theNewestWindow);		ShowMessage(theNewestWindow);		GetDialogItem(theNewestWindow, CALCULATE_BUTTON, iType, iHandle, iRect);		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);		DoOutlineControl(iHandle);		PopUpMenuInit(theNewestWindow);		SetPort(oldPort);	end;{--------------->      HandleAbout     <--}	procedure HandleAbout;		var			iHit, iType, theTabulator: INTEGER;			iRect, aboutRect: Rect;			iHandle: Handle;			dialogDone: BOOLEAN;	begin		if gAboutDialog = nil then			gAboutDialog := GetNewDialog(gResourceBase, nil, WindowPtr(-1));		SelectWindow(gAboutDialog);		ShowWindow(gAboutDialog);		SetPort(gAboutDialog);		aboutRect := gAboutDialog^.portRect;		GetDialogItem(gAboutDialog, ABOUT_OK_BUTTON, iType, iHandle, iRect);		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);		DoOutlineControl(iHandle);		dialogDone := FALSE;		while DialogDone = FALSE do			begin				ModalDialog(nil, iHit);				case iHit of					ABOUT_OK_BUTTON: 						begin							HideWindow(gAboutDialog);							dialogDone := TRUE;						end;				end;			end;	end;{--------------->     HandleCopyResult     <--}	procedure HandleCopyResult (theDialog: DialogPtr);		var			caseData: CaseRecordHnd;			theString: Str255;			ResultPtr: Ptr;			thelength: LongInt;	begin		caseData := CaseRecordHnd(GetWRefCon(theDialog));		if caseData = nil then			ErrorHandler(gNoMEMORY);		HLock(Handle(CaseData));		theString := caseData^^.MessageString;		HUnlock(Handle(CaseData));		thelength := length(theString);		ResultPtr := NewPtr(thelength);		ResultPtr := Ptr(ord(@theString) + 1);		if ZeroScrap <> noErr then			ErrorHandler(gNoMEMORY)		else if PutScrap(thelength, 'TEXT', ResultPtr) <> noErr then			ErrorHandler(gNoMEMORY);		DisposePtr(ResultPtr);	end;{--------------->     HandleEditChoice     <--}	procedure HandleEditChoice (theItem: INTEGER);		var			result: Boolean;			theDialog: DialogPtr;			iErr: OSErr;	begin		if IsDialogWindow(frontWindow) then			begin				theDialog := frontWindow;				case theItem of					CUT_ITEM: 						begin							DialogCut(theDialog);							if ZeroScrap = noErr then								iErr := TEToScrap;						end;					COPY_ITEM: 						begin							DialogCopy(theDialog);							if ZeroScrap = noErr then								iErr := TEToScrap;						end;					PASTE_ITEM: 						begin							iErr := TEFromScrap;							DialogPaste(theDialog);						end;					CLEAR_ITEM: 						DialogDelete(theDialog);					COPY_RESULT_ITEM: 						HandleCopyResult(theDialog);					otherwise						result := SystemEdit(theItem - 1);				end;			end		else			result := SystemEdit(theItem - 1);	end;{--------------->     NumberForm     <--}	function NumberForm (compos: integer; theString: Str255): extended;	{Wandelt String in Fließkommazahl um}		var			num, wholeS, remainderS: Str255;			whole, remainder: longint;	begin		wholeS := copy(theString, 1, compos - 1);		StringToNum(wholeS, whole);		remainderS := copy(theString, compos + 1, (length(theString) - compos));		StringToNum(remainderS, remainder);		NumberForm := whole + remainder / exp(ln(10) * length(remainderS));	end;{--------------->     ValidKey     <--}	function ValidKey (theKey: char): boolean;	{Beschränkt Texteingabe auf zulässige Zeichen}		type			format1 = set of char;		var			theformatn, theformatd, theformate, theformato, theformatc, thevalidformat: format1;	begin		ValidKey := false;		theformatn := ['1'..'9', '0', kTAB];		theformatd := ['.', ','];		theformate := ['e', 'E'];		theformato := ['+', '-'];		theformatc := [char($1c), char($1d), char($1e), char($1f), char($08)];		thevalidformat := theformatn + theformatd + theformate + theformatc;		if thekey in thevalidformat then			ValidKey := true		else			SysBeep(30);	end;{--------------->     StandardForm     <--}	function StandardForm (theString: Str255): extended;		var			compos: integer;			num, wholeS, remainderS: Str255;			whole, remainder: longint;	begin		compos := pos(DEC_COMMA, theString);		if compos > 0 then			StandardForm := NumberForm(compos, theString)		else			begin				compos := pos(DEC_POINT, theString);				if compos > 0 then					StandardForm := NumberForm(compos, theString)				else					begin						StringToNum(theString, whole);						StandardForm := whole;					end;			end;	end;{--------------->     HandleFileChoice     <--}	procedure HandleFileChoice (theItem: INTEGER);		var			whichWindow: WindowPtr;	begin		case theItem of			NEW_ITEM: 				CreateWindow;			CLOSE_ITEM: 				begin					whichWindow := FrontWindow;					if whichWindow <> nil then						if IsDialogWindow(WindowPtr(gTheEvent.message)) then							DisposeDialog(whichWindow)						else							DisposeWindow(whichWindow);				end;			PAGE_SETUP_ITEM: 				PageSetup;			PRINT_ITEM: 				Print;			QUIT_ITEM: 				gDone := TRUE;		end;	end;{--------------->     HandleAppleChoice     <--}	procedure HandleAppleChoice (theItem: INTEGER);		var			accName: Str255;			accNumber, itemNumber: INTEGER;			aMenu: MenuHandle;	begin		case theItem of			ABOUT_ITEM: 				HandleAbout;			otherwise				begin					if gResourceBase = GERMAN_RES_BASE then						aMenu := GetMenuHandle(GER_APPLE_MENU_ID)					else						aMenu := GetMenuHandle(EN_APPLE_MENU_ID);					GetMenuItemText(aMenu, theItem, accName);					accNumber := OpenDeskAcc(accName);				end;		end;	end;{--------------->     HandleMenuChoice     <--}	procedure HandleMenuChoice (menuChoice: LONGINT);		var			theMenu, theItem: INTEGER;	begin		if menuChoice <> 0 then			begin				theMenu := HiWord(menuChoice);				theItem := LoWord(menuChoice);				case theMenu of					GER_APPLE_MENU_ID, EN_APPLE_MENU_ID: 						HandleAppleChoice(theItem);					GER_FILE_MENU_ID, EN_FILE_MENU_ID: 						HandleFileChoice(theItem);					GER_EDIT_MENU_ID, EN_EDIT_MENU_ID: 						HandleEditChoice(theItem);				end;				HiliteMenu(0);			end;	end;{--------------->     ShowResultSheet     <--}	procedure ShowResultSheet (motherWindow: WindowPtr; theData: CaseRecordHnd);		var			resultSheet: DialogPtr;			iHit, iType: INTEGER;			theRect, iRect: Rect;			iHandle: Handle;			dialogDone: BOOLEAN;			origFont, origSize: INTEGER;			oldPort: GrafPtr;			theString: Str255;	begin		resultSheet := GetNewDialog(gResourceBase + 4, nil, WindowPtr(-1));		MoveWindow(resultSheet, WindowPeek(motherWindow)^.strucRgn^^.rgnBBox.left - 3, WindowPeek(motherWindow)^.contRgn^^.rgnBBox.top, LEAVE_WHERE_IT_IS);		SelectWindow(resultSheet);		ShowWindow(resultSheet);		GetPort(oldPort);		SetPort(resultSheet);		origFont := resultSheet^.txFont;		origSize := resultSheet^.txSize;		TextFont(applFont);		TextSize(10);		GetDialogItem(resultSheet, RESULT_CAPTION, iType, iHandle, iRect);		MoveTo(iRect.left, iRect.bottom + 20);		theRect := iRect;		with theRect do			begin				left := left - 2;				top := iRect.bottom + 10;				bottom := top + 100;				right := left + 100;			end;		theString := theData^^.SheetString1;		TETextBox(Pointer(ord(@theString) + 1), length(theString), theRect, teFlushLeft);		with theRect do			begin				left := right + 30;				right := resultSheet^.portRect.right - 20;			end;		theString := theData^^.SheetString2;		TETextBox(Pointer(ord(@theString) + 1), length(theString), theRect, teFlushLeft);		GetDialogItem(resultSheet, RESULT_OK_BUTTON, iType, iHandle, iRect);		HiliteControl(ControlHandle(iHandle), CONTROL_ACTIVATE);		DoOutlineControl(iHandle);		dialogDone := FALSE;		while DialogDone = FALSE do			begin				ModalDialog(nil, iHit);				case iHit of					RESULT_OK_BUTTON: 						begin							HideWindow(resultSheet);							dialogDone := TRUE;						end;				end;			end;		TextFont(origFont);		TextSize(origSize);		SetPort(oldPort);	end;{--------------->     HandleInput     <--}	procedure HandleInput (whichWindow: WindowPtr);		const			kTSH_Label = 'TSH: ';			kFT4_Label = 'FT4: ';			kT4_Label = 'T4: ';			kFT3_Label = 'FT3: ';			kT3_Label = 'T3: ';			kspaces = '   ';		var			subsString: Str255;			TSHLabel, T4Label, sT4Label, T3Label, sT3Label: Str255;			sizeL: LongInt;			iType, item, result: Integer;			iHandle, point_handle, comma_handle, text_handle: Handle;			iRect: Rect;			myErr: OSErr;			caseData: CaseRecordHnd;	begin		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(gNoMEMORY);		HLock(Handle(CaseData));		if caseData^^.T4Method = free then			begin				T4Label := concat(kspaces, kFT4_Label);				sT4Label := kFT4_Label;			end		else			begin				T4Label := concat(kspaces, kT4_Label);				sT4Label := kT4_Label;			end;		if caseData^^.T3Method = free then			begin				T3Label := concat(kspaces, kFT3_Label);				sT3Label := kFT3_Label;			end		else			begin				T3Label := concat(kspaces, kT3_Label);				sT3Label := kT3_Label;			end;		subsString := DEC_POINT;		GetDialogItem(whichWindow, TSH_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, TSH_String);		TSH := StandardForm(TSH_String);		TSH := TSH * caseData^^.TSHUnitFactor;		TSH_String := StringOf(TSH : 1 : 2);		GetDialogItem(whichWindow, FT4_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, FT4_String);		T4 := StandardForm(FT4_String);		T4 := T4 * UFT4;		T4 := T4 * caseData^^.FT4UnitFactor;		FT4_String := StringOf(T4 / (caseData^^.FT4UnitFactor * UFT4) : 1 : 2);		GetDialogItem(whichWindow, FT3_Text, iType, iHandle, iRect);		GetDialogItemText(iHandle, FT3_String);		T3 := StandardForm(FT3_String);		T3 := T3 * UFT3;		T3 := T3 * caseData^^.FT3UnitFactor;		FT3_String := StringOf(T3 / (caseData^^.FT3UnitFactor * UFT3) : 1 : 2);		Calculate(caseData^^.T4Method, caseData^^.T3Method);		GetMenuItemText(caseData^^.TSHPopUpMenu, caseData^^.TSHPopUpItem, TSH_Unit);		TSH_Unit := concat(' ', TSH_Unit);		GetMenuItemText(caseData^^.FT4PopUpMenu, caseData^^.FT4PopUpItem, FT4_Unit);		FT4_Unit := concat(' ', FT4_Unit);		GetMenuItemText(caseData^^.FT3PopUpMenu, caseData^^.FT3PopUpItem, FT3_Unit);		FT3_Unit := concat(' ', FT3_Unit);		gMessageString := concat(gSignalString, kReturn, '   TSH: ', TSH_String, TSH_Unit, kReturn, T4Label, FT4_String, FT4_Unit, kReturn, T3Label, FT3_String, FT3_Unit);		gMessageString := concat(gMessageString, kReturn, kReturn, gParameterString, kReturn, '   GT: ', GTs, kReturn, '   GD: ', GDs);		{gMessageString := concat(gMessageString, kReturn, gRefExp, kReturn, gGTRef, kReturn, gGDRef);}		caseData^^.SheetString1 := concat('TSH: ', TSH_String, TSH_Unit, kReturn, sT4Label, FT4_String, FT4_Unit, kReturn, sT3Label, FT3_String, FT3_Unit);		caseData^^.SheetString2 := concat('GT: ', GTs, kReturn, 'GD: ', GDs);		caseData^^.TSH := TSH;		caseData^^.T4 := T4;		caseData^^.T3 := T3;		caseData^^.GT := GT;		caseData^^.GD := GD;		caseData^^.MessageString := gMessageString;		caseData^^.MessageLabel := gResultString;		HUnlock(Handle(CaseData));		ShowMessage(whichWindow);		ShowResultSheet(whichWindow, CaseData);	end;{----------------> AdjustUnitFactors <--}	procedure AdjustUnitFactors (caseData: CaseRecordHnd);	begin		caseData^^.TSHUnitFactor := 1;		case caseData^^.T4MethodPopUpItem of			1: 				caseData^^.T4Method := free;			3: 				caseData^^.T4Method := total;		end;		case caseData^^.T3MethodPopUpItem of			1: 				caseData^^.T3Method := free;			3: 				caseData^^.T3Method := total;		end;		case caseData^^.T4Method of			free: 				case caseData^^.FT4PopUpItem of					1: 						caseData^^.FT4UnitFactor := 1;					2: 						caseData^^.FT4UnitFactor := 0.1;					4: 						caseData^^.FT4UnitFactor := 1 / UFT4 / 1e12;				end;			total: 				case caseData^^.FT4PopUpItem of					1: 						caseData^^.FT4UnitFactor := 100;					2: 						caseData^^.FT4UnitFactor := 1000;					4: 						caseData^^.FT4UnitFactor := 1 / UFT4 / 1e9;				end;		end;		case caseData^^.T3Method of			free: 				case caseData^^.FT3PopUpItem of					1, 2: 						caseData^^.FT3UnitFactor := 1;					4: 						caseData^^.FT3UnitFactor := 1 / UFT3 / 1e12;				end;			total: 				case caseData^^.FT3PopUpItem of					1: 						caseData^^.FT3UnitFactor := 1000;					2: 						caseData^^.FT3UnitFactor := 10;					4: 						caseData^^.FT3UnitFactor := 1 / UFT3 / 1e9;				end;		end;		AdjustMenus;	end;{----------------> DoContentClick <--}	procedure DoContentClick (whichWindow: WindowPtr);		var			oldPort: GrafPtr;			origSize, origFont, item: Integer;			theDialog: DialogPtr;			thePoint, popUpUpperLeft: Point;			theChoice: longint;			caseData: CaseRecordHnd;	begin		GetPort(oldPort);		SetPort(whichWindow);		thePoint := gTheEvent.where;		GlobalToLocal(thePoint);		origSize := whichWindow^.txSize;		origFont := whichWindow^.txFont;		caseData := CaseRecordHnd(GetWRefCon(whichWindow));		if caseData = nil then			ErrorHandler(gNoMEMORY);		HLock(Handle(CaseData));		if IsDialogEvent(gTheEvent) then			begin				if DialogSelect(gTheEvent, theDialog, item) then					if item = CALCULATE_BUTTON then						HandleInput(whichWindow);				if PtInRect(thePoint, gTSHPopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gTSHPopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gTSHPopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gTSHPopUpRect);						theChoice := PopUpMenuSelect(caseData^^.TSHPopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.TSHPopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.TSHPopUpItem := LoWord(theChoice);							end;						FrameRect(gTSHPopUpRect);					end; {if PtInRect}				if PtInRect(thePoint, gFT4PopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gFT4PopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gFT4PopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gFT4PopUpRect);						theChoice := PopUpMenuSelect(caseData^^.FT4PopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.FT4PopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.FT4PopUpItem := LoWord(theChoice);							end;						FrameRect(gFT4PopUpRect);					end; {if PtInRect}				if PtInRect(thePoint, gFT3PopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gFT3PopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gFT3PopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gFT3PopUpRect);						theChoice := PopUpMenuSelect(caseData^^.FT3PopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.FT3PopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.FT3PopUpItem := LoWord(theChoice);							end;						FrameRect(gFT3PopUpRect);					end; {if PtInRect}				if PtInRect(thePoint, gT4MethodPopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gT4MethodPopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gT4MethodPopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gT4MethodPopUpRect);						theChoice := PopUpMenuSelect(caseData^^.T4MethodPopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.T4MethodPopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.MethodsChanged := true;								caseData^^.WindowofChange := whichWindow;								caseData^^.FT4PopUpItem := 1;								caseData^^.T4MethodPopUpItem := LoWord(theChoice);							end;					end; {if PtInRect}				if PtInRect(thePoint, gT3MethodPopUpRect) then					begin						TextSize(POPUP_SIZE);						TextFont(applFont);						popUpUpperLeft.v := gT3MethodPopUpRect.top + PIXEL_FOR_TOP_LINE;						popUpUpperLeft.h := gT3MethodPopUpRect.left;						LocalToGlobal(popUpUpperLeft);						EraseRect(gT3MethodPopUpRect);						theChoice := PopUpMenuSelect(caseData^^.T3MethodPopUpMenu, popUpUpperLeft.v, popUpUpperLeft.h, caseData^^.T3MethodPopUpItem);						if LoWord(theChoice) > 0 then							begin								caseData^^.MethodsChanged := true;								caseData^^.WindowofChange := whichWindow;								caseData^^.FT3PopUpItem := 1;								caseData^^.T3MethodPopUpItem := LoWord(theChoice);							end;					end; {if PtInRect}			end;		AdjustUnitFactors(caseData);		AdjustMenus;		DrawPopUpItems(whichWindow);		HUnLock(Handle(CaseData));		TextSize(origSize);		TextFont(origFont);		SetPort(oldPort);	end;{----------------> HandleMouseDown <--}	procedure HandleMouseDown;		var			whichWindow: WindowPtr;			thePart: INTEGER;			menuChoice, windSize: LONGINT;			theRect: rect;	begin		thePart := FindWindow(gTheEvent.where, whichWindow);		case thePart of			inMenuBar: 				begin					menuChoice := MenuSelect(gTheEvent.where);					HandleMenuChoice(menuChoice);				end;			inSysWindow: 				SystemClick(gTheEvent, whichWindow);			inDrag: 				begin					SelectWindow(whichWindow);					theRect := GetGrayRgn^^.rgnBBox;					DragWindow(whichWindow, point(gTheEvent.where), rect(theRect));				end;			inGoAway: 				if TrackGoAway(whichWindow, gTheEvent.where) then					if IsDialogWindow(WindowPtr(gTheEvent.message)) then						DisposeDialog(whichWindow)					else						DisposeWindow(whichWindow);			inContent: 				if whichWindow <> FrontWindow then					SelectWindow(whichWindow)				else					DoContentClick(whichWindow);		end;	end;{----------------> HandleKeyDown <--}	procedure HandleKeyDown;		var			key: Char;			iType, item: Integer;			iHandle: Handle;			iRect: Rect;			finalTicks: UInt32;			handled: Boolean;			theDialog: DialogPtr;	begin		handled := FALSE;		theDialog := FrontWindow;		key := Char(BAnd(gTheEvent.message, charCodeMask));		if (key = char(kRETURN)) or (key = char(kENTER)) then			begin				if theDialog <> nil then					begin						SetPort(theDialog);						GetDialogItem(theDialog, CALCULATE_BUTTON, iType, iHandle, iRect);						HiliteControl(ControlHandle(iHandle), inButton);						Delay(kVISUAL, finalTicks);						HiliteControl(ControlHandle(iHandle), 0);						HandleInput(theDialog);						handled := TRUE;					end				else					begin						item := NoteAlert(gResourceBase + 10, nil);						handled := true;					end;			end;		if (BitAnd(gTheEvent.modifiers, cmdKey) <> 0) then			begin				AdjustMenus;				HandleMenuChoice(MenuKey(key));				handled := TRUE;			end;		if not handled then			if theDialog <> nil then				begin					if validkey(key) then						handled := DialogSelect(gTheEvent, theDialog, item);				end			else				item := NoteAlert(gResourceBase + 10, nil);	end;{----------------> HandleEvent <--}	procedure HandleEvent;		var			theChar: CHAR;			gotEvent, result: BOOLEAN;			oldPort: GrafPtr;			window: WindowPtr;			iHit, state: Integer;			control: ControlHandle;			iType, item: integer;			iHandle: Handle;			iRect: Rect;			theErr: OSErr;	begin		if gWNEImplemented then			gotEvent := WaitNextEvent(everyEvent, gTheEvent, MIN_SLEEP, nil)		else			begin				SystemTask;				gotEvent := GetNextEvent(everyEvent, gTheEvent);			end;		if gotEvent then			case gTheEvent.what of				kHighLevelEvent: 					begin						theErr := AEProcessAppleEvent(gTheEvent);					end;				mouseDown: 					begin						AdjustMenus;						HandleMouseDown;					end;				keyDown, autoKey: 					begin						HandleKeyDown;					end;				activateEvt: 					begin						state := BAnd(gTheEvent.modifiers, activeFlag);						if (IsDialogWindow(WindowPtr(gTheEvent.message))) and (WindowPtr(gTheEvent.message) <> gAboutDialog) then							begin								control := controlHandle(WindowPeek(WindowPtr(gTheEvent.message))^.controlList);								while control <> nil do									begin										HiliteControl(control, state + 255 mod 256);										control := control^^.nextControl;										GetDialogItem(WindowPtr(gTheEvent.message), CALCULATE_BUTTON, iType, iHandle, iRect);										DoOutlineControl(iHandle);									end;							end;					end;				updateEvt: 					if not IsDAWindow(WindowPtr(gTheEvent.message)) then						begin							AdjustMenus;							GetPort(oldPort);							SetPort(WindowPtr(gTheEvent.message));							BeginUpdate(WindowPtr(gTheEvent.message));							UpdateDialog(WindowPtr(gTheEvent.message), WindowPtr(gTheEvent.message)^.visRgn);							ShowMessage(WindowPtr(gTheEvent.message));							EndUpdate(WindowPtr(gTheEvent.message));							GetDialogItem(WindowPtr(gTheEvent.message), CALCULATE_BUTTON, iType, iHandle, iRect);							DoOutlineControl(iHandle);							DrawPopUps(WindowPtr(gTheEvent.message));							SetPort(oldPort);						end;				nullEvent: 					begin						window := FrontWindow;						if IsDialogWindow(FrontWindow) then							result := DialogSelect(gTheEvent, window, item);					end;				osEvt: 					begin						HiliteMenu(0);					end;			end		else			begin				window := FrontWindow;				if IsDialogWindow(FrontWindow) then					result := DialogSelect(gTheEvent, window, item);			end;	end;{----------------> MainLoop <--}	procedure MainLoop;	begin		gDone := FALSE;		gWNEImplemented := (NGetTrapAddress(WNE_TRAP_NUM, ToolTrap) <> NGetTrapAddress(UNIMPL_TRAP_NUM, ToolTrap));		while (gDone = FALSE) do			HandleEvent;		SavePreferences;{PrClose;}	end;{----------------> MenuBarInit <--}	procedure MenuBarInit;		var			myMenuBar: Handle;			aMenu: MenuHandle;	begin		myMenuBar := GetNewMBar(gResourceBase);		if myMenuBar = nil then			ErrorHandler(gNoMBAR);		SetMenuBar(myMenuBar);{--- DisposeHandle(myMenuBar); ---}		if gResourceBase = GERMAN_RES_BASE then			aMenu := GetMenuHandle(GER_APPLE_MENU_ID)		else			aMenu := GetMenuHandle(EN_APPLE_MENU_ID);		if aMenu = nil then			ErrorHandler(gNoMENU);		AppendResMenu(aMenu, 'DRVR');		if gResourceBase = GERMAN_RES_BASE then			aMenu := GetMenu(GER_EDIT_MENU_ID)		else			aMenu := GetMenu(EN_EDIT_MENU_ID);		if aMenu = nil then			ErrorHandler(gNoMENU);		if gResourceBase = GERMAN_RES_BASE then			aMenu := GetMenu(GER_FILE_MENU_ID)		else			aMenu := GetMenu(EN_FILE_MENU_ID);		if aMenu = nil then			ErrorHandler(gNoMENU);		DrawMenuBar;	end;{----------------> InitEvents <--}	procedure InitEvents;		var			theErr: OSErr;			response: longint;	begin		gDoOpenAppEventUPP := NewAEEventHandlerProc(AEEventHandlerProcPtr(@HandleOpenApplicationEvent));		gDoQuitAppEventUPP := NewAEEventHandlerProc(AEEventHandlerProcPtr(@DoQuitEvent));		if (Gestalt(gestaltSystemVersion, response) = noErr) and (response >= $0700) then			begin				theErr := AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, gDoQuitAppEventUPP, 0, false);				if theErr = noErr then					theErr := AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, gDoOpenAppEventUPP, 0, false);				if theErr <> noErr then					SysBeep(30);				FlushEvents(everyEvent, 0);			end;	end;{----------------> SPINA-Thyr <--}begin	MaxApplZone;	MoreMasters;	InitGraf(@qd.thePort);	InitFonts;	InitWindows;	InitMenus;	TEInit;	InitDialogs(nil);	FlushEvents(everyEvent, 0);	InitCursor;	SetCursor(GetCursor(watchCursor)^^);	gGermanCodes := [3, 19, 70, 92];	{verGermany, verGrSwiss, verGermanReformed, verAustria}	gItl0Handle := Intl0Hndl(GetIntlResource(0));	gRegion := BitAnd(gItl0Handle^^.intl0Vers, $FF00);	gRegion := BitShift(gRegion, -8);	if gRegion in gGermanCodes then		gResourceBase:= GERMAN_RES_BASE	else		gResourceBase:= ENGLISH_RES_BASE;	gNoMBAR := gResourceBase;	gNoMENU := gResourceBase + 1;	gNoPICTURE := gResourceBase + 2;	gNoWIND := gResourceBase + 3;	gNoTEXT := gResourceBase + 4;	gNoMEMORY := gResourceBase + 5;	gAboutAlert := gResourceBase;	gErrorAlertID := gResourceBase + 1;	MenuBarInit;	InitEvents;	gSplashDialog := GetNewDialog(gResourceBase + 3, nil, WindowPtr(-1));	SelectWindow(gSplashDialog);	ShowWindow(gSplashDialog);	SetPort(gSplashDialog);	DrawDialog(gSplashDialog);	PrintInit;	gNewWindowLeft := WINDOW_HOME_LEFT;	gNewWindowTop := WINDOW_HOME_TOP;	gcalcCounter := 0;	SetRect(gMessageRect, 10, 136, 148, 238);	GetIndString(gnotcalculatableString, gResourceBase, 1);	GetIndString(gExplanationString, gResourceBase, 2);	GetIndString(gRefExp, gResourceBase, 3);	GetIndString(gGTRef, gResourceBase, 4);	GetIndString(gGDRef, gResourceBase, 5);	GetIndString(gSignalString, gResourceBase, 6);	GetIndString(gParameterString, gResourceBase, 7);	GetIndString(gSheetMessage, gResourceBase, 8);	GetIndString(gPatName, gResourceBase + 1, 1);	GetIndString(gPatBirthday, gResourceBase + 1, 2);	GetIndString(gPatSender, gResourceBase + 1, 3);	GetIndString(gPrintingDate, gResourceBase + 1, 4);	GetIndString(gChooserName, gResourceBase + 1, 5);	GetIndString(gExaminationDate, gResourceBase + 1, 6);	GetIndString(gHintString, gResourceBase + 1, 7);	GetIndString(gResultString, gResourceBase + 1, 8);	GetIndString(gStandardCalcTitle, gResourceBase + 1, 9);	ObscureCursor();	gAppResFileRefNum := CurResFile;	BlankPreferences;	GetPreferences;	Delay(30, gfinalTicks);	HideWindow(gSplashDialog);	CreateWindow;	SetCursor(qd.arrow);	ShowCursor;	MainLoop;end.